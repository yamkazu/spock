# Japanese translations for Spock Framework package.
# Copyright (C) 2012, Peter Niederwieser
# This file is distributed under the same license as the Spock Framework package.
# Kazuki YAMAMOTO <>, 2013.
#
msgid ""
msgstr ""
"Project-Id-Version: Spock Framework 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-02-14 00:20\n"
"PO-Revision-Date: 2013-02-14 00:27+0900\n"
"Last-Translator: Kazuki YAMAMOTO <>\n"
"Language-Team: Japanese\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

# ec75457c18744582936c6f5920f499db
#: ../../interaction_based_testing.rst:4
msgid "Interaction Based Testing"
msgstr "相互作用中心のテスト"

# 5803f5c0f91343c19b7e806a15e44430
#: ../../interaction_based_testing.rst:6
msgid ""
"Interaction-based testing is a design and testing technique that emerged in "
"the Extreme Programming (XP) community in the early 2000's. Focusing on the "
"behavior of objects rather than their state, it explores how the object(s) "
"under specification interact, by way of method calls, with their "
"collaborators."
msgstr ""
"相互作用中心のテストは2000年代前半に登場したExtreme Programming（XP）から生まれた設計、テスト技法です。"
"オブジェクトの状態ではなく、メソッドの呼び出しによって、仕様対象オブジェクトがコラボレータとどのように相互作用するのかという、オブジェクトの振る舞いに注目します。"

# debfa7f02af44cb6a423fd0a260359be
#: ../../interaction_based_testing.rst:10
msgid ""
"For example, suppose we have a ``Publisher`` that sends messages to its "
"``Subscriber``'s::"
msgstr ""
"例えば複数の\\ ``Subscriber``\\ にメッセージを送信する\\ ``Publisher``\\ があるとしましょう。"

# cbddea3c0bc44615a81ce0a543bc79ca
#: ../../interaction_based_testing.rst:25
msgid ""
"How are we going to test ``Publisher``? With state-based testing, we can "
"verify that the publisher keeps track of its subscribers. The more "
"interesting question, though, is whether a message sent by the publisher is "
"received by the subscribers. To answer this question, we need a special "
"implementation of ``Subscriber`` that listens in on the conversation between "
"the publisher and its subscribers. Such an implementation is often called a "
"*mock object*."
msgstr ""
"どのように\\ ``Publisher``\\ をテストすればよいでしょうか？ "
"状態中心のテストではpublisherがsubscriberを追跡できているか検証します。"
"しかし、ここでの興味は「publisherが送ったメッセージを、subscriberが受信できたか」です。"
"この問いに答えるには、publisherとsubscriberのやり取りを監視しする\\ ``Subscriber``\\ の特別な実装が必要です。"
"この特別な実装はよく\\ *モックオブジェクト*\\ と呼ばれます。"

# 7e7ca8ee5001456c92ea6821bba2c5a9
#: ../../interaction_based_testing.rst:31
msgid ""
"While we could certainly create a mock implementation of ``Subscriber`` by "
"hand, writing and maintaining this code can get unpleasant as the number of "
"methods and complexity of interactions increases. This is where mocking "
"frameworks come in: They provide a way to describe the expected interactions "
"between an object under specification and its collaborators, and can "
"generate mock implementations of collaborators that verify these "
"expectations."
msgstr ""
"subscriberのモック実装を自前で作成することもできます。"
"しかし、メソッドの数が多かったり、相互作用が複雑なメソッドが増えてくると、このコードを書いたりメンテナンスするのが煩わしくなります。"
"そこで、モックフレームワークの出番です。"
"このフレームワークは、仕様対象のオブジェクトとコラボレータの間に期待する相互作用を宣言する方法を提供します。"
"さらに、この期待する相互作用を検証する、コラボレータのモック実装を生成できます。"

# 24e8bec5a9bd4c10bdeff0a92bc789ce
#: ../../interaction_based_testing.rst:38
msgid ""
"Like most Java mocking frameworks, Spock uses `JDK dynamic proxies <http://"
"docs.oracle.com/javase/7/docs/api/>`_ (when mocking interfaces) and `CGLIB "
"<http://cglib.sourceforge.net>`_ proxies (when mocking classes) to generate "
"mock implementations at runtime. Compared to implementations based on Groovy "
"meta-programming, this has the advantage that it also works for testing Java "
"code."
msgstr ""
"（質問: どのようにモック実装は生成されるか？）"
"よくあるJavaのモックフレームワークと同様に、Spockは実行時にモック実装を生成するため、\\ `JDKの動的プロキシ <http://docs.oracle.com/javase/7/docs/api/>`_\\ （インタフェースのモック時）、\\ `CGLIB <http://cglib.sourceforge.net>`_\\ プロキシ（クラスをモック時）を使用します。"
"これは、実装にGroovyのメタプラグラミングを使用するのに比べ、Javaコードをテストする際に有利に働きます。"

# d0dd89c9f6b144b0b02acbb9aa9f1181
#: ../../interaction_based_testing.rst:43
msgid ""
"The Java world has no shortage of popular and mature mocking frameworks: "
"`JMock <http://www.jmock.org/>`_, `EasyMock <http://www.easymock.org/>`_, "
"`Mockito <http://code.google.com/p/mockito/>`_, to name just a few. Although "
"each of these tools can be used together with Spock, we decided to roll our "
"own mocking framework, tightly integrated with Spock's specification "
"language. This decision was driven by the desire to leverage all of Groovy's "
"capabilities to make interaction-based tests easier to write, more readable, "
"and ultimately more fun. We hope that by the end of this chapter, you will "
"agree that we have achieved these goals."
msgstr ""
"Javaの世界では、\\ `JMock <http://www.jmock.org/>`_\\ 、\\ `EasyMock <http://www.easymock.org/>`_\\ 、\\ `Mockito <http://code.google.com/p/mockito/>`_\\ といった、人気があり成熟したモックフレームワークに事欠きません。"
"これらのモックフレームワークを、Spockと共に使用することもできます。"
"しかし、Spockの言語仕様に合うように、モックフレームワークをSpock自身で再開発することを決めました。"
"この判断は、Groovyの能力を最大限活用して、より簡単に相互作用中心のテストを書けるようにし、より読みやすく、また最高に楽しいものにしたいという思いからです。"
"この章を読み終えた時に、その目標が達成されていると感じていただけると幸いです。"

# 4283b6f8f4274562a5d7f6d9199ad9fd
#: ../../interaction_based_testing.rst:50
msgid ""
"Except where indicated, all features of Spock's mocking framework work both "
"for testing Java and Groovy code."
msgstr ""
"特に明示していない限り、モックフレームワークのすべての機能はJavaコードとGroovyコードのテスト両方で使用できます。"

# 843766b3049a4ec7b1a78e71767197ab
#: ../../interaction_based_testing.rst:53
msgid "Creating Mock Objects"
msgstr "モックオブジェクトの作成"

# d15e89ba2a48421cae3abbff619354e7
#: ../../interaction_based_testing.rst:55
msgid ""
"Mock objects are created with the ``MockingApi.Mock()`` method [#creating]_. "
"Let's create two mock subscribers::"
msgstr ""
"モックオブジェクトは\\ ``MockingApi.Mock()``\\ メソッドで作成します\\ [#creating]_\\ 。"
"2つのsubscriberモックを作成してみましょう。"

# 12a6c83680a1401c92cc9ea29f7875ed
#: ../../interaction_based_testing.rst:60
msgid ""
"Alternatively, the following Java-like syntax is supported, which may give "
"better IDE support::"
msgstr ""
"または、Javaに近いシンタックスもサポートしています。"
"これは、IDEのサポートがより受けやすくなるかもしれません。"

# 6b8b1190c5b442929500e1f6d669d45c
#: ../../interaction_based_testing.rst:65
msgid ""
"Here, the mock's type is inferred from the variable type on the left-hand "
"side of the assignment."
msgstr ""
"この場合のモックの型は、左辺の変数の型から推論されます。"

# 5ca22ed0f5484584b8008aab18278335
#: ../../interaction_based_testing.rst:67
msgid ""
"If the mock's type is given on the left-hand side of the assignment, it's "
"permissible (though not required) to omit it on the right-hand side."
msgstr ""
"もしモックの型を左辺で指定した場合は、右辺で型を省略できます（指定しても問題ありません）。"

# 40f827a8103e457383377bbb220e02bd
#: ../../interaction_based_testing.rst:70
msgid ""
"Mock objects literally implement (or, in the case of a class, extend) the "
"type they stand in for. In other words, in our example ``subscriber`` *is-a* "
"``Subscriber``. Hence it can be passed to statically typed (Java) code that "
"expects this type."
msgstr ""
"モックオブジェクトは文字通りその型の実装（クラスの場合は継承）します。"
"別の言い方をすると、上記の例のsubscriberは\\ *is-a* ``Subscriber``\\です。"
"つまり、この型を期待する静的型付けのコード（Java）に、この実装を渡せるということです。"

# 92b15d3b0c0d44d8a26f37dffc24ea58
#: ../../interaction_based_testing.rst:75
msgid "Default Behavior of Mock Objects"
msgstr "モックオブジェクトのデフォルト動作"

# ea4f6095988d4ef6812df44e535f6e5a
#: ../../interaction_based_testing.rst:79
msgid ""
"Like Mockito, we firmly believe that a mocking framework should be lenient "
"by default. This means that unexpected method calls on mock objects (or, in "
"other words, interactions that aren't relevant for the test at hand) are "
"allowed and answered with a default response. Conversely, mocking frameworks "
"like EasyMock and JMock are strict by default, and throw an exception for "
"every unexpected method call. While strictness enforces rigor, it can also "
"lead to over-specification, resulting in brittle tests that fail with every "
"other internal code change. Spock's mocking framework makes it easy to "
"describe only what's relevant about an interaction, avoiding the over-"
"specification trap."
msgstr ""
"（質問: Lenient vs Strictなモックフレームワーク）"
"Mockitoのように、モックフレームワークはデフォルトでlenient（緩い）であるべきだと考えています。"
"これはモックオブジェクトに対して予期しないメソッドの呼び出し（別の言い方をすると、テストと関係のない相互作用）を許容し、その呼び出しに対しデフォルトのレスポンスを返すことを意味します。"
"逆にEasyMock、JMockといったモックフレームワークはデフォルトでstrict（厳格）です。"
"このstrictなモックフレームワークは、予期しないメソッドの呼び出しに例外を投げます。"
"このような厳密性の強制はover-specification（詳細すぎる仕様）を引き起こします。"
"これは、内部のコード変更で、すぐにテストが失敗する「壊れやすいテスト」という結果をもたらします。"
"Spockのモックフレームワークは、関係のある相互作用だけを簡単に宣言できるようにすることで、over-specificationのトラップを回避します。"

# cf77246bfb6441debd3f255bf615b39f
#: ../../interaction_based_testing.rst:86
msgid ""
"Initially, mock objects have no behavior. Calling methods on them is allowed "
"but has no effect other than returning the default value for the method's "
"return type (``false``, ``0``, or ``null``). An exception are the ``Object."
"equals``, ``Object.hashCode``, and ``Object.toString`` methods, which have "
"the following default behavior: A mock object is only equal to itself, has a "
"unique hash code, and a string representation that includes the name of the "
"type it represents. This default behavior is overridable by stubbing the "
"methods, which we will learn about in the `Stubbing`_ section."
msgstr ""
"初期状態のモックは何の振る舞いもしません。"
"このオブジェクトのメソッドを呼び出すことは可能ですが、戻り値の型に応じたデフォルト値（\\ ``false``\\ 、\\ ``0``\\、または\\ ``null``\\ ）を返す以外は何もしません。"
"ただし\\ ``Object.equals``\\ 、\\ ``Object.hashCode``\\ 、\\ ``Object.toString``\\ メソッドは例外です。"
"モックオブジェクトはオブジェクトごとに一意のハッシュコードを持ち、自身との比較にのみ等しくなります。"
"そして\\ ``Object.toString``\\ は、モックをした型を含んだ文字列を返します。"
"これらのデフォルトの動作はスタビングで上書き可能です。"
"詳しくは\\ :ref:`スタビング <Stubbing>`\\ のセクションで説明します。"

# da8994c41e7a43b8a2553a67729422f5
#: ../../interaction_based_testing.rst:93
msgid "Injecting Mock Objects into Code Under Specification"
msgstr "仕様対象へモックオブジェクトを設定する"

# bfa13eeb62654adeae594fead2271469
#: ../../interaction_based_testing.rst:95
msgid ""
"After creating the publisher and its subscribers, we need to make the latter "
"known to the former::"
msgstr ""
"publisherとモックのsubscriberを作成した後に、publisherにsubscriberを設定する必要があります。"

# 30335c8a92ea4482832a90b74282c2d2
#: ../../interaction_based_testing.rst:108
msgid ""
"We are now ready to describe the expected interactions between the two "
"parties."
msgstr ""
"これで2つのオブジェクト間に期待する相互作用を宣言する準備が整いました。"

# 6e9b615a816a46e6a3aff1e3c4129e74
#: ../../interaction_based_testing.rst:111
msgid "Mocking"
msgstr "モッキング（訳注: Mocking）"

# be2452128cb34aca894ac477050b5496
#: ../../interaction_based_testing.rst:113
msgid ""
"Mocking is the act of describing (mandatory) interactions between the object "
"under specification and its collaborators. Here is an example::"
msgstr ""
"モッキングとは、仕様対象のオブジェクトとそのコラボレータ間の、（必須の）インタラクション（訳注: ここまで相互作用と表記してきましたが、Spockではインタラクションを用語として使用しているため、以降インタラクションと表記します）を宣言する活動です。"
"次の例を見てください。"

# b8109a44526043bfb0a9c3b825217ca3
#: ../../interaction_based_testing.rst:125
msgid ""
"Read out aloud: \"When the publisher sends a 'hello' message, then both "
"subscribers should receive that message exactly once.\""
msgstr ""
"音読すると"
"「publisher が 'hello' のメッセージを send したとき、両方の subscriber は 1回 message を receive すべき」"
"になります。（訳注: コードが英語の文章のように読めると言っている）"

# 91ae211516c54c659901daca01dd8b90
#: ../../interaction_based_testing.rst:127
msgid ""
"When this feature method gets run, all invocations on mock objects that "
"occur while executing the ``when`` block will be matched against the "
"interactions described in the ``then:`` block. If one of the interactions "
"isn't satisfied, a (subclass of) ``InteractionNotSatisfiedError`` will be "
"thrown. This verification happens automatically and does not require any "
"additional code."
msgstr ""
"このフィーチャメソッドを実行すると、\\ ``when:``\\ ブロック内で発生するモックオブジェクトへのすべての呼び出しが、\\ ``then:``\\ ブロックで宣言したインタラクションと照合されます。"
"もし、インタラクションが1つでも満たされない場合は\\ ``InteractionNotSatisfiedError``\\ （のサブクラス）が投げられます。"
"この検証は自動的に行われます。開発者自身で検証コードを記述する必要はありません。"

# be33d88d5f3141f497456c847fc5da94
#: ../../interaction_based_testing.rst:133
msgid "Interactions"
msgstr "インタラクション"

# 27703cd55f37403d907950416aa5d7e1
#: ../../interaction_based_testing.rst:137
msgid ""
"Not quite. While an interaction looks similar to a regular method "
"invocation, it is simply a way to express which method invocations are "
"expected to occur. A good way to think of an interaction is as a regular "
"expression that all incoming invocations on mock objects are matched "
"against. Depending on the circumstances, the interaction may match zero, "
"one, or multiple invocations."
msgstr ""
"（質問: インタラクションは通常のメソッド呼び出しか？）"
"もちろん、そんなことはありません。"
"インタラクションは通常のメソッド呼び出しのように見えます。しかし、インタラクションは期待するメソッド呼び出しを、わかりやすく表現する方法にすぎません。"
"このインタラクションは、モックオブジェクトに発生する、すべての呼び出しに対する正規表現と考えるよいでしょう。"
"状況によって、インタラクションが0回マッチするかもしれませんし、1回、または複数回マッチするかもしれません。"

# d496b838aad345629eea4eb09cf0a80c
#: ../../interaction_based_testing.rst:142
msgid ""
"Let's take a closer look at the ``then:`` block. It contains two "
"*interactions*, each of which has four distinct parts: a *cardinality*, a "
"*target constraint*, a *method constraint*, and an *argument constraint*::"
msgstr ""
"それでは、``then:``\\ ブロックについて詳しく見ていきましょう。"
"上記の例では2つの\\ *インタラクション*\\ を宣言しています。"
"この2つのインタラクションは、\\ *多重度（訳注: cardinality）*\\ 、\\ *対象制約（訳注: target constraint）*\\ 、\\ *メソッド制約（訳注: method constraint）*\\ 、そして\\ *引数制約（訳注: argument constraint）*\\ の4つのパートから成り立っています。"

# e81001af510f4785ab5bfaeb5f3f5358
#: ../../interaction_based_testing.rst:153
msgid "Cardinality"
msgstr "多重度"

# 97b577ab60bf4adca010687ef58d4f33
#: ../../interaction_based_testing.rst:155
msgid ""
"The cardinality of an interaction describes how often a method call is "
"expected. It can either be a fixed number or a range::"
msgstr ""
"多重度は、何回メソッド呼び出しを期待しているかを表します。"
"この多重度の指定には固定の数値、または範囲が使用できます。"

# f9b110fd388d4db0b4b7cbf2fc64ef28
#: ../../interaction_based_testing.rst:166
msgid "Target Constraint"
msgstr "対象制約"

# 152deec0237540a1a2d07454f65c6759
#: ../../interaction_based_testing.rst:168
msgid ""
"The target constraint of an interaction describes which mock object is "
"expected to receive the method call::"
msgstr ""
"対象制約は、どのモックオブジェクトにメソッド呼び出しを期待しているかを表します。"

# e2e656ab80a34aa89e52d0b0c617ccee
#: ../../interaction_based_testing.rst:174
msgid "Method Constraint"
msgstr "メソッド制約"

# 7827e705dae54027906eb1d0626a4f6e
#: ../../interaction_based_testing.rst:176
msgid ""
"The method constraint of an interaction describes which method is expected "
"to be called::"
msgstr ""
"メソッド制約は、どのメソッドに呼び出しを期待しているかを表します。"

# 2b94d1219446478c88bd63a30abe2a82
#: ../../interaction_based_testing.rst:182
msgid ""
"When expecting a call to a getter method, Groovy property syntax *can* be "
"used instead of method syntax::"
msgstr ""
"ゲッターメソッドの呼び出しを期待する場合は、通常のメソッドのシンタックスの代わりにGroovyのプロパティ構文が使用できます。"

# e00d2250ebc347c2ae5216213044e292
#: ../../interaction_based_testing.rst:186
msgid ""
"When expecting a call to a setter method, only method syntax can be used::"
msgstr ""
"セッターメソッドの呼び出しを期待する場合は、メソッドのシンタックスのみが使用できます。"

# 922b9cdcc93842ebb533f0e576994bab
#: ../../interaction_based_testing.rst:191
msgid "Argument Constraints"
msgstr "引数制約"

# ac224ec010b843f7a379bc445be3697e
#: ../../interaction_based_testing.rst:193
msgid ""
"The argument constraints of an interaction describe which method arguments "
"are expected::"
msgstr ""
"引数制約は、どんなメソッド引数を期待しているかを表します。"

# a185b9bd01604d5caa517f00c4e2b4ca
#: ../../interaction_based_testing.rst:205
msgid ""
"Argument constraints work as expected for methods with multiple arguments::"
msgstr ""
"引数制約は複数の引数を持つメソッドにも使用できます。"

# 607bcfd285c0441ebef7bc92e267ae89
#: ../../interaction_based_testing.rst:209
msgid ""
"When dealing with vararg methods, vararg syntax can also be used in the "
"corresponding interactions::"
msgstr ""
"可変長引数のメソッドを扱う場合も、これまでのインタラクションと同じように可変長引数のシンタックスが使用できます。"

# acc5f693a51b4b3ca00bf183a8707c08
#: ../../interaction_based_testing.rst:221
msgid ""
"Groovy allows any method whose last parameter has an array type to be called "
"in vararg style. Consequently, vararg syntax can also be used in "
"interactions matching such methods."
msgstr ""
"Groovyでは最後のパラメータが配列であるメソッドに対して、可変長引数形式の呼び出しを許可しています。"
"可変長引数のシンタックスは、このようなメソッドのインタラクションのマッチングにも使用できます。"

# 14cd2169aba94449b8480464e4f10e0f
#: ../../interaction_based_testing.rst:225
msgid "Matching Any Method Call"
msgstr "いくつかのメソッド呼び出しに対するマッチング"

# 8e83a78da53f4e8aacbceedb37701063
#: ../../interaction_based_testing.rst:227
msgid ""
"Sometimes it can be useful to match \"anything\", in some sense of the word::"
msgstr ""
"言葉の意味どおり「何にでも」一致というのが便利な場面があります。"

# 1bcbbe46c8ec4e52bbab7cf46855b643
#: ../../interaction_based_testing.rst:235
msgid ""
"Although ``(_.._) * _._(*_) >> _`` is a valid interaction declaration, it is "
"neither good style nor particularly useful."
msgstr ""
"\\ ``(_.._) * _._(*_) >> _``\\ は有効なインタラクションの宣言です。"
"しかし、良いスタイルでもなければ、便利な場面があるわけでもありません。"

# 59e83546c22047bc8f90c18f87fcfa20
#: ../../interaction_based_testing.rst:239
msgid "Strict Mocking"
msgstr "Strictモッキング"

# 192f5fb0081d4765a3b4b32e12b68201
#: ../../interaction_based_testing.rst:241
msgid ""
"Now, when would matching any method call be useful? A good example is "
"*strict mocking*, a style of mocking where no interactions other than those "
"explicitly declared are allowed::"
msgstr ""
"上記の「いくつかのメソッド呼び出しに対するマッチング」はどのような場合に便利でしょうか？ "
"よい例が\\ *strictモッキング*\\ です。"
"このモッキングのスタイルは、明示的に宣言した以外のインタラクションを許可しません。"

# 90528da444804393a3710cc342f89b3c
#: ../../interaction_based_testing.rst:252
msgid ""
"``0 *`` only makes sense as the last interaction of a ``then:`` block or "
"method. Note the use of ``_ *`` (any number of calls), which allows any "
"interaction with the auditing component."
msgstr ""
"このように\\ ``0 *``\\ は\\ ``then:``\\ ブロックの最後、またはメソッドの最後のインタラクションとした場合にのみ効果を発揮します。"
"また\\ ``_ *``\\ （任意の呼び出し回数）は、auditingコンポーネントに対して任意の呼び出し回数を許容しています。"

# 2c90f36ada0643ffb41c8df0d7d21e5c
#: ../../interaction_based_testing.rst:255
msgid ""
"``_ *`` is only meaningful in the context of strict mocking. In particular, "
"it is never necessary when :ref:`stubbing <Stubbing>` an invocation. For "
"example, ``_ * auditing.record(_) >> \"ok\"`` can (and should!) be "
"simplified to ``auditing.record(_) >> \"ok\"``."
msgstr ""
"``_ *``\\ は、strictモッキングで使用する場合にのみ意味があります。"
"特に\\ :ref:`スタビング <Stubbing>`\\ で必要になることは絶対にありません。"
"例えば\\ ``_ * auditing.record(_) >> \"ok\"``\\ は、単に\\ ``auditing.record(_) >> \"ok\"``\\ とすべきです。"

# d4d4f1d3c3374d30b7f64f75219c2dd3
#: ../../interaction_based_testing.rst:262
msgid "Where to Declare Interactions"
msgstr "インタラクションの宣言場所"

# c8a950dba7aa4d1895fb8316438b25e7
#: ../../interaction_based_testing.rst:264
msgid ""
"So far, we declared all our interactions in a ``then:`` block. This often "
"results in a spec that reads naturally. However, it is also permissible to "
"put interactions anywhere *before* the ``when:`` block that is supposed to "
"satisfy them. In particular, this means that interactions can be declared in "
"a ``setup`` method. Interactions can also be declared in any \"helper\" "
"instance method of the same specification class."
msgstr ""
"ここまではインタラクションを、\\ ``then:``\\ ブロックに宣言してきました。"
"これはスペックがより自然に読めるという効果があります。"
"しかし、インタラクションは\\ ``when:``\\ ブロックの\\ *前*\\ であればどこでも宣言できます。"
"具体的には、\\ ``setup``\\ といったメソッドで宣言できるという意味です。"
"同様に、ヘルパークラスのメソッドで宣言するといったことも可能です。"

# b3d04638403d4663a9491afa4f22893f
#: ../../interaction_based_testing.rst:269
msgid ""
"When an invocation on a mock object occurs, it is matched against "
"interactions in the interactions' declared order. If an invocation matches "
"multiple interactions, the earliest declared interaction that hasn't reached "
"its upper invocation limit will win. There is one exception to this rule: "
"Interactions declared in a ``then:`` block are matched against before any "
"other interactions. This allows to override interactions declared in, say, a "
"``setup`` method with interactions declared in a ``then:`` block."
msgstr ""
"モックオブジェクトへの呼び出しが発生すると、宣言した順番でインタラクションを照合します。"
"もし、呼び出しが複数のインタラクションにマッチする場合は、インタラクションが実行上限に達してない限り、先に宣言したインタラクションが優先されます。"
"ただし1つ例外があります。"
"\\ ``then:``\\ ブロックで宣言したインタラクションは、他のインタラクションより先に照合されます。"
"これにより、\\ ``setup``\\ メソッドで宣言したインタラクションを、\\ ``then:``\\ ブロックで宣言したインタラクションで上書きできます。"

# 9840aea6a6ce4022a010da2193e74d2d
#: ../../interaction_based_testing.rst:277
msgid ""
"In other words, what makes an expression an interaction declaration, rather "
"than, say, a regular method call? Spock uses a simple syntactic rule to "
"recognize interactions: If an expression is in statement position and is "
"either a multiplication (``*``) or a left-shift (``>>``, ``>>>``) operation, "
"then it is considered an interaction and will be parsed accordingly. Such an "
"expression would have little to no value in statement position, so changing "
"its meaning works out fine. Note how the operations correspond to the syntax "
"for declaring a cardinality (when mocking) or a response generator (when "
"stubbing). Either of them must always be present; ``foo.bar()`` alone will "
"never be considered an interaction."
msgstr ""
"（質問: どのようにインタラクションを識別するのか？） "
"別の言い方をすると、通常のメソッド呼び出しではなく、どのようにインタラクションの宣言を表現しているか？ "
"Spockにはインタラクションを識別するための、簡単なシンタックスのルールがあります。"
"これは、式に乗算（\\ ``*``\\ ）、または左シフト（\\ ``>>``, ``>>>``\\ ）が含まれていた場合、その式をインタラクションとして識別するというルールです。"
"このような式は、値が持つ意味をほぼ無効にし、式本来の意味を変えることで、正しく動作します。"
"これらの演算子は、多重度（モッキング時）、またはレスポンスジェネレータ（スタビング時）のシンタックスに対応します。"
"インタラクションには、この多重度の演算子、またはレスポンスジェネレータの演算子、どちらかが必要です。"
"\\ ``foo.bar()``\\ といった単独の式は、インタラクションとして扱われません。"

# 08b0975f40aa457688984f769623f0c5
#: ../../interaction_based_testing.rst:288
msgid "Declaring Interactions at Mock Creation Time (New in 0.7)"
msgstr "モック作成時のインタラクション宣言（New in 0.7）"

# ec27a82373794705b5ffc83d308d0b29
#: ../../interaction_based_testing.rst:290
msgid ""
"If a mock has a set of \"base\" interactions that don't vary, they can be "
"declared right at mock creation time::"
msgstr ""
"もしモックが変化しない\"基底\"となるインタラクションがある場合は、モック作成時にインタラクションを宣言できます。"

# 5afcecf8d1cf499595f8ca06bad1e56b
#: ../../interaction_based_testing.rst:297
msgid ""
"This feature is particularly attractive for :ref:`stubbing <Stubbing>` and "
"with dedicated `Stubs`_. Note that the interactions don't (and cannot "
"[#targetContext]_) have a target constraint; it's clear from the context "
"which mock object they belong to."
msgstr ""
"この機能は、専用の\\ :ref:`スタブ <Stubs>`\\ で\\ :ref:`スタビング <Stubbing>`\\ するのに特に便利な機能です。"
"ここで、インタラクションに対象制約が含れていない（含められない\\ [#targetContext]_\\ ）ことに注意してください。"
"これは対象となるモックオブジェクトが明白なためです。"

# 596cb22985674a0586ad32d60a3d92ac
#: ../../interaction_based_testing.rst:301
msgid ""
"Interactions can also be declared when initializing an instance field with a "
"mock::"
msgstr ""
"インスタンスフィールドをモックで初期化する場合にも使用できます。"

# 5bd33a5bc850471c9ecff02914849e40
#: ../../interaction_based_testing.rst:313
msgid "Grouping Interactions with Same Target (New in 0.7)"
msgstr "インタラクションのグループ化（New in 0.7）"

# b5f406a14c4e430bbaa32092a34dbd8f
#: ../../interaction_based_testing.rst:315
msgid ""
"Interactions sharing the same target can be grouped in a ``Specification."
"with`` block. Similar to :ref:`declaring interactions at mock creation time "
"<DeclaringInteractionsAtMockCreationTime>`, this makes it unnecessary to "
"repeat the target constraint::"
msgstr ""
"``Specification.with``\\ ブロックを使用してインタラクション対象を共有することで、インタラクションをグループ化できます。"
"これは\\ :ref:`モック作成時のインタラクション宣言\\ <DeclaringInteractionsAtMockCreationTime>`\\ と同じように、対象制約を繰り返し指定する必要がなくなります。"

# 0873c63f191e41e096ef18a7f3f03689
#: ../../interaction_based_testing.rst:324
msgid ""
"A ``with`` block can also be used for grouping conditions with the same "
"target."
msgstr ""
"また、\\ ``with``\\ ブロックは特定の対象に対する、コンディションのグループ化にも使用できます。"

# ad0064f04dc64f1dbbf1f99139e98180
#: ../../interaction_based_testing.rst:327
msgid "Mixing Interactions and Conditions"
msgstr "インタラクションとコンディションの組み合わせ"

# 9772b3b772fd4c669ae8fb8e7aca8d7a
#: ../../interaction_based_testing.rst:329
msgid ""
"A ``then:`` block may contain both interactions and conditions. Although not "
"strictly required, it is customary to declare interactions before "
"conditions::"
msgstr ""
"``then:``\\ ブロックにインタラクションと、コンディションの両方を含む場合があります。"
"厳密には必須ではありませんが、慣例的にコンディションの前にインタラクションを宣言します。"

# 11245c092de149da8e987b67a8f3462d
#: ../../interaction_based_testing.rst:339
msgid ""
"Read out aloud: \"When the publisher sends a 'hello' message, then the "
"subscriber should receive the message exactly once, and the publisher's "
"message count should be one.\""
msgstr ""
"音読すると"
"「publisher が 'hello' のメッセージを send したとき、subscriber は 1回 message を receive し、publisher の message count は 1 であるべき」"
"になります。（訳注: インタラクションを先に宣言した方が、英語として自然に読めると言っている）"

# c349252f6bf84850a9ca2c8056d0ce3c
#: ../../interaction_based_testing.rst:343
msgid "Explicit Interaction Blocks"
msgstr "明示的なインタラクションブロック"

# 392e3daa569448cc8831adf3519e873f
#: ../../interaction_based_testing.rst:345
msgid ""
"Internally, Spock must have full information about expected interactions "
"*before* they take place. So how is it possible for interactions to be "
"declared in a ``then:`` block? The answer is that under the hood, Spock "
"moves interactions declared in a ``then:`` block to immediately before the "
"preceding ``when:`` block. In most cases this works out just fine, but "
"sometimes it can lead to problems::"
msgstr ""
"仕組み上、Spockは実行\\ *前*\\ に宣言されているインタラクション全ての情報を把握しなければなりません。"
"では、どのように\\ ``then:``\\ ブロック内でのインタラクション宣言を可能にしているのでしょうか？ "
"答えはSpockの内部にあります。"
"Spockは、\\ ``then:`` \\ ブロックのインタラクション宣言を、\\ ``when:``\\ ブロックを処理する直前へ移動します。"
"これは多くの場合に問題なく動作します。"
"しかし、特定の条件下では問題が起きます。"

# 806f4afad39f458fa89965f0599c9a68
#: ../../interaction_based_testing.rst:357
msgid ""
"Here we have introduced a variable for the expected argument. (Likewise, we "
"could have introduced a variable for the cardinality.) However, Spock isn't "
"smart enough (huh?) to tell that the interaction is intrinsically linked to "
"the variable declaration. Hence it will just move the interaction, which "
"will cause a ``MissingPropertyException`` at runtime."
msgstr ""
"ここでは、期待する引数を変数に受けています（多重度を変数に受ける場合も同様）。"
"しかし、Spockはインタラクションが変数宣言へ参照を持っていると把握するほど賢くありません。"
"そのため、インタラクションをそのまま移動し、実行時に\\ ``MissingPropertyException``\\ を引き起こします。"

# fea4deb35c7041619cee28bfaa6cf8e5
#: ../../interaction_based_testing.rst:362
msgid ""
"One way to solve this problem is to move (at least) the variable declaration "
"to before the ``when:`` block. (Fans of :ref:`data-driven testing "
"<DataDrivenTesting>` might move the variable into a ``where:`` block.) In "
"our example, this would have the added benefit that we could use the same "
"variable for sending the message."
msgstr ""
"この問題を解決する一つの方法は、変数宣言を（少なくとも）\\ ``when:``\\ ブロックの前に移動することです"
"（\\ :ref:`データ駆動テスト <DataDrivenTesting>`\\ が好きなユーザは\\ ``where:``\\ ブロックに変数を移動するかもしれません）。"
"上記の例では、送信するメッセージと同じ変数を使用できるという利点もあるでしょう。"

# cfab1b38d4fd4f97bcf26017fc4e5985
#: ../../interaction_based_testing.rst:366
msgid ""
"Another solution is to be explicit about the fact that variable declaration "
"and interaction belong together::"
msgstr ""
"他の解決方法は、変数をインタラクションと共に使用することを明示する方法です。"

# d3edff9f195846f5b891ab3172bd633f
#: ../../interaction_based_testing.rst:377
msgid ""
"Since an ``MockingApi.interaction`` block is always moved in its entirety, "
"the code now works as intended."
msgstr ""
"``MockingApi.interaction``\\ ブロックは、常にブロック全体が移動するため、このコードは意図したとおりに動作します。"

# 25be090c816b481c9bd635321510790b
#: ../../interaction_based_testing.rst:380
msgid "Scope of Interactions"
msgstr "インタラクションのスコープ"

# 461a388537e44c2b906272225e4a3332
#: ../../interaction_based_testing.rst:382
msgid ""
"Interactions declared in a ``then:`` block are scoped to the preceding "
"``when:`` block::"
msgstr ""
"``then:``\\ ブロックで宣言したインタラクションは、直前の\\ ``when:``\\ ブロックをスコープとします。"

# f40bfad2d9b641a381907a35e3292ade
#: ../../interaction_based_testing.rst:396
msgid ""
"This makes sure that ``subscriber`` receives ``\"message1\"`` during "
"execution of the first ``when:`` block, and ``\"message2\"`` during "
"execution of the second ``when:`` block."
msgstr ""
"これは最初の\\ ``when:``\\ ブロックで\\ ``subscriber``\\ が\\ ``\"message1\"``\\ を受信し、次の\\ ``when:``\\ ブロックで\\ ``\"message2\"``\\ を受信した確認をしています。"

# 9d56f46a1c244f0e80cbb8d36e9adf92
#: ../../interaction_based_testing.rst:399
msgid ""
"Interactions declared outside a ``then:`` block are active from their "
"declaration until the end of the containing feature method."
msgstr ""
"``then:``\\ ブロックの外で宣言したインタラクションは、そのフィーチャメソッドが完了するまで有効です。"

# bb4888b632b14848946afcddbbf88b82
#: ../../interaction_based_testing.rst:402
msgid ""
"Interactions are always scoped to a particular feature method. Hence they "
"cannot be declared in a static method, ``setupSpec`` method, or "
"``cleanupSpec`` method. Likewise, mock objects should not be stored in "
"static or ``@Shared`` fields."
msgstr ""
"また、インタラクションは常に特定のフィーチャメソッドへスコープを持ちます。"
"そのため、インタラクションをstaticメソッド、\\ ``setupSpec``\\  メソッド、または\\ ``cleanupSpec``\\ メソッドで宣言することはできません。"
"同様に、モックオブジェクトはstatic、または\\ ``@Shared``\\ フィールドに保持すべきではありません。"

# 08444aea9ae145ffbc249d12094622be
#: ../../interaction_based_testing.rst:407
msgid "Verification of Interactions"
msgstr "インタラクションの検証"

# c0bc449e82484a33b9f2110f6b1b4e33
#: ../../interaction_based_testing.rst:409
msgid ""
"There a two main ways in which a mock-based test can fail: An interaction "
"can match more invocations than allowed, or it can match fewer invocations "
"than required. The former case is detected right when the invocation "
"happens, and causes a ``TooManyInvocationsError``::"
msgstr ""
"モックベースのテストが失敗する主な原因は2つあります。"
"インタラクションを許可した以上の実行がマッチした場合、もしくは意図したよりもマッチした実行が少ない場合です。"
"前者の場合は、その状況を検知すると、\\ ``TooManyInvocationsError``\\ を発生させます。"

# e00f4e234867490b83796ef19b8004aa
#: ../../interaction_based_testing.rst:419
msgid ""
"To make it easier to diagnose why too many invocations matched, Spock will "
"show all invocations matching the interaction in question (new in Spock "
"0.7)::"
msgstr ""
"なぜマッチした呼び出しが多すぎたのか解析しやすいように、Spockは問題となるインタラクションにマッチしたすべての呼び出しを表示します（new in Spock 0.7）。"

# 7c9ee5fb12564f83bd5fc73a83cbee46
#: ../../interaction_based_testing.rst:427
msgid ""
"According to this output, one of the ``receive(\"hello\")`` calls triggered "
"the ``TooManyInvocationsError``. Note that because indistinguishable calls "
"like the two invocations of ``subscriber.receive(\"hello\")`` are aggregated "
"into a single line of output, the first ``receive(\"hello\")`` may well have "
"occurred before the ``receive(\"goodbye\")``."
msgstr ""
"この出力によると、\\ ``receive(\"hello\")``\\ の呼び出しの1つが\\ ``TooManyInvocationsError``\\ を引き起こしています。"
"ここで、\\ ``subscriber.receive(\"hello\")``\\ のような2つの呼び出しは、1行に集約されて表示されます。"
"最初の\\ ``subscriber.receive(\"hello\")``\\ は\\ ``receive(\"goodbye\")``\\ の前に発生していたかもしれませんが、この出力からは区別できません。"

# b71364945e7b485588aacef64bae4cd1
#: ../../interaction_based_testing.rst:431
msgid ""
"The second case (fewer invocations than required) can only be detected once "
"execution of the ``when`` block has completed. (Until then, further "
"invocations may still occur.) It causes a ``TooFewInvocationsError``::"
msgstr ""
"2つめの場合（意図したよりも実行が少ない場合）は、\\ ``when``\\ ブロックの実行が完了した時点でのみ検出できます（終了するまでは呼び出しの可能性があるため）。"
"検出した場合は\\ ``TooFewInvocationsError``\\ を発生させます。"

# a975655d13a54dcfb6b77527448c6050
#: ../../interaction_based_testing.rst:438
msgid ""
"Note that it doesn't matter whether the method was not called at all, the "
"same method was called with different arguments, the same method was called "
"on a different mock object, or a different method was called \"instead\" of "
"this one; in either case, a ``TooFewInvocationsError`` error will occur."
msgstr ""
"これはメソッドの呼び出しが、一切なかったということではありません。"
"同じメソッドが、他の引数で呼び出された、異なるモックオブジェクトで呼び出された、もしくは、\"別の\"メソッドが呼び出された、といったことが考えられます。"
"これらいずれの場合でも、\\ ``TooFewInvocationsError``\\ が発生します。"

# a5c3cbfc0f564150b51e22dca4ba8e71
#: ../../interaction_based_testing.rst:444
msgid ""
"To make it easier to diagnose what happened \"instead\" of a missing "
"invocation, Spock will show all invocations that didn't match any "
"interaction, ordered by their similarity with the interaction in question "
"(new in Spock 0.7). In particular, invocations that match everything but the "
"interaction's arguments will be shown first::"
msgstr ""
"なぜ意図しない呼び出しが代わりに起きたのか解析しやすいよう、Spockはどのインタラクションにもマッチしなかったすべての呼び出しを表示します。"
"この呼び出しは、問題のあるインタラクションに類似している順番で表示されます（new in Spock 0.7）。"
"特に、インタラクションの引数以外がすべて一致する呼び出しが最初に表示されます。"

# 45d741277a17466ba6334bd9d7117582
#: ../../interaction_based_testing.rst:454
msgid "Invocation Order"
msgstr "実行順序"

# 224b146103ab4eee8104ec104f54b0c3
#: ../../interaction_based_testing.rst:456
msgid ""
"Often, the exact method invocation order isn't relevant and may change over "
"time. To avoid over-specification, Spock defaults to allowing any invocation "
"order, provided that the specified interactions are eventually satisfied::"
msgstr ""
"多くの場合に、正確なメソッドの実行順序に意味はありません。"
"また、この実行順序は時間と共に変わる可能性があります。"
"over-specificationを避けるため、Spockはデフォルトで、最終的に宣言したインタラクションすべてが満たされれば、どのような実行順序も許容します。"

# f2530818dd4d47ceab5ddefbd574f563
#: ../../interaction_based_testing.rst:463
msgid ""
"Here, any of the invocation sequences ``\"hello\"`` ``\"hello\"`` ``\"goodbye"
"\"``, ``\"hello\"`` ``\"goodbye\"`` ``\"hello\"``, and ``\"goodbye\"`` ``"
"\"hello\"`` ``\"hello\"`` will satisfy the specified interactions."
msgstr ""
"ここで、呼び出し順序が ``\"hello\"`` ``\"hello\"`` ``\"goodbye"
"\"``、``\"hello\"`` ``\"goodbye\"`` ``\"hello\"``、または ``\"goodbye\"`` ``"
"\"hello\"`` ``\"hello\"`` いずれの場合も宣言したインタラクションを満たします。"

# 2374f3bb6a0743f4a17590dae87df65b
#: ../../interaction_based_testing.rst:466
msgid ""
"In those cases where invocation order matters, you can impose an order by "
"splitting up interactions into multiple ``then:`` blocks::"
msgstr ""
"実行順序に意味がある場合は、インタラクションを分割した複数の\\ ``then:``\\ ブロックの順序で検証できます。"

# 0847a86faa6a477ba933c58efc5fef87
#: ../../interaction_based_testing.rst:475
msgid ""
"Now Spock will verify that both ``\"hello\"``'s are received before the ``"
"\"goodbye\"``. In other words, invocation order is enforced *between* but "
"not *within* ``then:`` blocks."
msgstr ""
"これは\\ ``\"goodby\"``\\ を受信する前に、\\ ``\"hello\"``\\ を2回受信することを検証します。"
"別の言い方をすると、\\ ``then:``\\ ブロック\\ *内*\\ ではなく、\\ ``then:``\\ ブロック\\ *間*\\ で実行順序を強制させます。"

# 147969b5b4aa478f87f661478a3d9b1b
#: ../../interaction_based_testing.rst:478
msgid ""
"Splitting up a ``then:`` block with ``and:`` does not impose any ordering, "
"as ``and:`` is only meant for documentation purposes and doesn't carry any "
"semantics."
msgstr ""
"\\ ``then:``\\ ブロックを\\ ``and:``\\ で分割した場合は、順序を指定していることにはなりません。"
"\\ ``and:``\\ はドキュメンテーション目的のためだけに存在しており、それ以外の意味はありません。"

# 2dc1ec483ab14dbbbdff3be437004502
#: ../../interaction_based_testing.rst:482
msgid "Mocking Classes"
msgstr "クラスのモッキング"

# ba3de6a30bd746ca9d9f79964c0dd9f9
#: ../../interaction_based_testing.rst:484
msgid ""
"Besides interfaces, Spock also supports mocking of classes. Mocking classes "
"works just like mocking interfaces; the only additional requirement is to "
"put ``cglib-nodep-2.2`` or higher and ``objenesis-1.2`` or higher on the "
"class path. If either of these libraries is missing from the class path, "
"Spock will gently let you know."
msgstr ""
"インタフェースの他に、Spockはクラスのモッキングもサポートしています。"
"クラスのモッキングも、インターフェースのモッキングと同じように使用できます。"
"ただし、クラスパスに\\ ``cglib-nodep-2.2``\\ 以上、\\ ``objenesis-1.2``\\ 以上が必要になります。"
"もしこれらのライブラリいずれかが、クラスパスに含まれていない場合は、Spockがやさしくそれを知らせるでしょう。"

# d07bd4f127f24d909709390ed6b4c0cd
#: ../../interaction_based_testing.rst:492
msgid "Stubbing"
msgstr "スタビング（Stubbing）"

# 4426e06b49ee4254a4b989b07f715bc2
#: ../../interaction_based_testing.rst:494
msgid ""
"Stubbing is the act of making collaborators respond to method calls in a "
"certain way. When stubbing a method, you don't care if and how many times "
"the method is going to be called; you just want it to return some value, or "
"perform some side effect, *whenever* it gets called."
msgstr ""
"スタビングとは特定のメソッド呼び出しに対するレスポンスを宣言することです。"
"メソッドをスタビングする場合は、そのメソッドが何回呼ばれるかを気にせず、"
"\\ *いつ呼び出されても*\\ 特定の値を返したり、何かの副作用が働くように"
"します。"

# 440bff2ef49248a6816c99ad81f6976a
#: ../../interaction_based_testing.rst:498
msgid ""
"For the sake of the following examples, let's modify the ``Subscriber``'s "
"``receive`` method to return a status code that tells if the subscriber was "
"able to process a message::"
msgstr ""
"例を示すために、\\ ``Subscriber``\\ の\\ ``receive``\\ メソッドの処理が"
"完了した場合に、ステータスコードを返すように変更してみましょう。"

# 56f4aa2005d94e1699564e7336344c5f
#: ../../interaction_based_testing.rst:505
msgid ""
"Now, let's make the ``receive`` method return ``\"ok\"`` on every "
"invocation::"
msgstr ""
"ここで\\ ``receive``\\ メソッドが常に\\ ``\"ok\"``\\ "
"を返すようにします。"

# 609c0e066b034d928bfe3353bba1d36d
#: ../../interaction_based_testing.rst:509
msgid ""
"Read out aloud: \"*Whenever* the subscriber receives a message, *make* it "
"respond with 'ok'.\""
msgstr ""
"文章としてコードを読んでみると「subscriber が メッセージ を 受信 するたびに 'ok' を返す」"
"になります。"

# 8a7856c68b8e490582ace72bec8d0d92
#: ../../interaction_based_testing.rst:511
msgid ""
"Compared to a mocked interaction, a stubbed interaction has no cardinality "
"on the left end, but adds a *response generator* on the right end::"
msgstr ""
"モック時のインタラクションと比べると、スタブのインタラクションは左に"
"多重度がない代わりに、右に\\ *レスポンスジェネレータ*\\ を指定します。"

# c28b3a6a6934485f93b4dcae3f4e7128
#: ../../interaction_based_testing.rst:521
msgid ""
"A stubbed interaction can be declared in the usual places: either inside a "
"``then:`` block, or anywhere before a ``when:`` block. (See :ref:"
"`WhereToDeclareInteractions` for the details.) If a mock object is only used "
"for stubbing, it's common to declare interactions :ref:`at mock creation "
"time <DeclaringInteractionsAtMockCreationTime>` or in a ``setup:`` block."
msgstr ""
"スタブのインタラクションは、\\ ``then:``\\ ブロック内や\\ ``when:``\\ ブロック"
"の前など、どのような場所でも宣言することができます"
"\\ （詳細は\\ :ref:`WhereToDeclareInteractions`\\ を参照）。"
"もし、モックオブジェクトをスタブとしてのみ使用する場合は、"
"\\ :ref:`モック作成時 <DeclaringInteractionsAtMockCreationTime>`\\ "
"や\\ ``setup:``\\ ブロック内でインタラクションを宣言するのが一般的です。"

# 8d45e48c3219471bb25d3e9b0c0c4397
#: ../../interaction_based_testing.rst:527
msgid "Returning Fixed Values"
msgstr "固定の値を返す"

# 17da48fdfb114d68b79d66883ccfb10f
#: ../../interaction_based_testing.rst:529
msgid ""
"We have already seen the use of the right-shift (``>>``) operator to return "
"a fixed value::"
msgstr ""
"すでにここまでの例の中で出てきましたが、固定の値を返すには算術右シフト（\\ ``>>``\\ ）演算子を使用します。"

# eaadb4b0b62c4417bff2a9fc47ba74ae
#: ../../interaction_based_testing.rst:533
msgid ""
"To return different values for different invocations, use multiple "
"interactions::"
msgstr ""
"呼び出し毎に異なる値を返すには、それぞれ個別のインタラクションとして宣言します。"

# d4f8bf87df614b639406ac0e8625e202
#: ../../interaction_based_testing.rst:538
msgid ""
"This will return ``\"ok\"`` whenever ``\"message1\"`` is received, and ``"
"\"fail\"`` whenever ``\"message2\"`` is received. There is no limit as to "
"which values can be returned, provided they are compatible with the method's "
"declared return type."
msgstr ""
"これは\\ ``\"message1\"``\\ を受信すると\\ ``\"ok\"``\\ を返し、"
"\\ ``\"message2\"``\\ を受信すると\\ ``\"fail\"`` を返します。"
"返す値に制限はありませんが、メソッドの戻り値型の制約を外れることはできません。"

# 0c631d0e8123444d86c3f0b4f4040361
#: ../../interaction_based_testing.rst:543
msgid "Returning Sequences of Values"
msgstr "一連の値を返す"

# 472886be566f49b5b6969a8c76bcb33b
#: ../../interaction_based_testing.rst:545
msgid ""
"To return different values on successive invocations, use the triple-right-"
"shift (``>>>``) operator::"
msgstr ""
"連続した呼び出しに対し異なる値を返すには、論理右シフト演算子（\\ ``>>>``\\ ）"
"を使用します。"

# 2fb82cf2b4bb488c8e75d66fb6b65890
#: ../../interaction_based_testing.rst:549
msgid ""
"This will return ``\"ok\"`` for the first invocation, ``\"error\"`` for the "
"second and third invocation, and ``\"ok\"`` for all remaining invocations. "
"The right-hand side must be a value that Groovy knows how to iterate over; "
"in this example, we've used a plain list."
msgstr ""
"これは初めの呼び出しに対し\\ ``\"ok\"``\\ を返し、2回目3回目には"
"\\ ``\"error\"``\\ 、そして4回目以降は\\ ``\"ok\"``\\ を"
"返します。右辺に指定する値はGroovyがイテレーション方法を知っている"
"値である必要があります。この例では単なるリストを使用しています。"

# ec73db87315c4c3eb0d862a1c23dbba0
#: ../../interaction_based_testing.rst:554
msgid "Computing Return Values"
msgstr "動的に値を返す"

# 19673f37fcf4433abfba45f67afd6663
#: ../../interaction_based_testing.rst:556
msgid ""
"To compute a return value based on the method's argument, use the the right-"
"shift (``>>``) operator together with a closure. If the closure declares a "
"single untyped parameter, it gets passed the method's argument list::"
msgstr ""
"メソッドの引数に応じて動的に値を返すには、算術右シフト（\\ ``>>``\\ ）演算子と"
"クロージャを使用します。もしクロージャの引数が、型指定なしで1つ"
"の場合は、引数のリストが渡されます。"

# 17a6bf845a204d40944dd9a9f67d7020
#: ../../interaction_based_testing.rst:561
msgid ""
"Here ``\"ok\"`` gets returned if the message is more than three characters "
"long, and ``\"fail\"`` otherwise."
msgstr ""
"これはメッセージの長さが3文字以上の場合は\\ ``\"ok\"``\\ を返し、"
"それ以外は\\ ``\"fail\"``\\ を返します。"

# 28ccb65c8c454d96b71e59e5c54dd82f
#: ../../interaction_based_testing.rst:563
msgid ""
"In most cases it would be more convenient to have direct access to the "
"method's arguments. If the closure declares more than one parameter or a "
"single *typed* parameter, method arguments will be mapped one-by-one to "
"closure parameters [#closureDestructuring]_::"
msgstr ""
"しかしほとんどのケースでは、メソッドの引数に直接アクセスできたほうが"
"便利でしょう。クロージャの引数を\\ *型付き*\\ で1つ以上宣言した場合は、"
"メソッドの引数がそれぞれクロージャの引数にマップされます。"
"\\ [#closureDestructuring]_\\ "

# 845ce791e29c4cd48a7df3cf6601189f
#: ../../interaction_based_testing.rst:569
msgid ""
"This response generator behaves the same as the previous one, but is "
"arguably more readable."
msgstr ""
"このモックは先程の例とまったく同じように動作しますが、"
"より読みやすくなっています。"

# c2d6e864b581419baa25c89cbf598fc1
#: ../../interaction_based_testing.rst:571
msgid ""
"If you find yourself in need of more information about a method invocation "
"than its arguments, have a look at ``org.spockframework.mock."
"IMockInvocation``. All methods declared in this interface are available "
"inside the closure, without a need to prefix them. (In Groovy terminology, "
"the closure *delegates* to an instance of ``IMockInvocation``.)"
msgstr ""
"もし、メソッドの引数以上に実行中のメソッドについて、情報が必要な場合は"
"\\ ``org.spockframework.mock.IMockInvocation``\\ を参照してください。"
"このインターフェース内の全てのメソッドは、クロージャ内からプレフィックス指定なしに"
"呼ぶことができます。（Groovyの用語で言うとクロージャは\\ ``IMockInvocation``\\ "
"のインスタンスへデリゲートします。）"

# cf5768548d804e77bc3e5cb6bb493a51
#: ../../interaction_based_testing.rst:576
msgid "Performing Side Effects"
msgstr "副作用の実行"

# b062639a86fe454bb0d36013b83b7c27
#: ../../interaction_based_testing.rst:578
msgid ""
"Sometimes you may want to do more than just computing a return value. A "
"typical example is throwing an exception. Again, closures come to the "
"rescue::"
msgstr ""
"場合によっては動的に値を返す以外の処理が必要になることがあります。"
"たとえば例外のスローです。このような場合にもクロージャを使用します。"

# 12cec0487c014ef8bebde49da8ac4e6f
#: ../../interaction_based_testing.rst:583
msgid ""
"Of course, the closure can contain more code, for example a ``println`` "
"statement. It will get executed every time an incoming invocation matches "
"the interaction."
msgstr ""
"もちろんクロージャの中には\\ ``println``\\ といった、さまざまなコードを"
"含むことができます。この例ではメソッドの呼び出しが、インタラクションと"
"一致するたびに例外をスローします。"

# 04e96047ccb94d8daa1cbdd7747d71c8
#: ../../interaction_based_testing.rst:587
msgid "Chaining Method Responses"
msgstr "メソッドのレスポンスをチェーンする"

# 4777d4f8581f400c98ba9be8fdce0455
#: ../../interaction_based_testing.rst:589
msgid "Method responses can be chained::"
msgstr "メソッドのレスポンスをチェーンすることができます。"

# f189e88c3bcf4198a0a6b17b19941d1d
#: ../../interaction_based_testing.rst:593
msgid ""
"This will return ``\"ok\", \"fail\", \"ok\"`` for the first three "
"invocations, throw ``InternalError`` for the fourth invocations, and return "
"``ok`` for any further invocation."
msgstr ""
"これは最初の3回の呼び出しに対し\\ ``\"ok\", \"fail\", \"ok\"``\\ "
"を返し、4回目には\\ ``InternalError``\\ をスロー、それ以降の"
"呼び出しには\\ ``ok``\\ を返します。"

# 710d3b3e1d9c45debc9a3b2f61d50b06
#: ../../interaction_based_testing.rst:597
msgid "Combining Mocking and Stubbing"
msgstr "モッキングとスタビングの組み合わせ"

# 62a98644f25d44d6bf27078669d6fdd2
#: ../../interaction_based_testing.rst:599
msgid "Mocking and stubbing go hand-in-hand::"
msgstr "モッキングとスタビングを組みわせて使用できます。"

# ae023a83692945379ba176a36ed39b60
#: ../../interaction_based_testing.rst:604
msgid ""
"When mocking and stubbing the same method call, they have to happen in the "
"same interaction. In particular, the following Mockito-style splitting of "
"stubbing and mocking into two separate statements will *not* work::"
msgstr ""
"モッキングとスタビングを同じメソッドに対して行う場合は、同じインタラクションとして"
"宣言する必要があります。これは、Mockitoのようにモッキングとスタビングを、"
"別々に宣言することが\\ *できない*\\ ということです。"

# b6f2c8d0b2f44fdbab3d1c66425b67c2
#: ../../interaction_based_testing.rst:617
msgid ""
"As explained in :ref:`WhereToDeclareInteractions`, the ``receive`` call will "
"first get matched against the interaction in the ``then:`` block. Since that "
"interaction doesn't specify a response, the default value for the method's "
"return type (``null`` in this case) will be returned. (This is just another "
"facet of Spock's lenient approach to mocking.). Hence, the interaction in "
"the ``setup:`` block will never get a chance to match."
msgstr ""
":ref:`WhereToDeclareInteractions`\\ で説明したように\\ ``receive``\\ が呼ばれると、"
"\\ ``then:``\\ ブロックで宣言したインタラクションが始めに評価されます。"
"このインタラクションは、特定のレスポンスを宣言していないため、メソッドの"
"デフォルトの値（この場合は\\ `null`\\ ）を返します（これはSpockがlenientなモック"
"のアプローチを採用しているためです）。このため、\\ ``setup:``\\ ブロックで"
"宣言したスタビングのインタラクションは評価されることがありません。"

# cbc4d7b4da774f2bbf80c1bf20bf526e
#: ../../interaction_based_testing.rst:623
msgid ""
"Mocking and stubbing of the same method call has to happen in the same "
"interaction."
msgstr ""
"同じメソッド呼び出しに対するモッキングとスタビングは、同じインタラクションとして"
"宣言する必要があります。"

# 665c938e1ff047d19f8e8a50f468bbdd
#: ../../interaction_based_testing.rst:628
msgid "Other Kinds of Mock Objects (New in 0.7)"
msgstr "他のモックオブジェクト（New in 0.7）"

# f0f538b1ce89418fa0390e955d3eaa91
#: ../../interaction_based_testing.rst:630
msgid ""
"So far, we have created mock objects with the ``MockingApi.Mock`` method. "
"Aside from this method, the ``MockingApi`` class provides a couple of other "
"factory methods for creating more specialized kinds of mock objects."
msgstr ""
"ここまでは\\ ``MockingApi.Mock``\\ メソッドを使用してモックを作成してきました。"
"\\ ``MockingApi``\\ クラスは、これ以外にも特別なモックを作成する"
"ファクトリメソッドを提供しています。"

# 9e07996a67684940b01e18812554ebb0
#: ../../interaction_based_testing.rst:637
msgid "Stubs"
msgstr "スタブ"

# 759ee03474474d7fa6f7217e1699175f
#: ../../interaction_based_testing.rst:639
msgid "A *stub* is created with the ``MockingApi.Stub`` factory method::"
msgstr "*スタブ*\\ は\\ ``MockingApi.Stub``\\ メソッドで作成します。"

# 9a27aa4bab644a6dba4d6c22958c6271
#: ../../interaction_based_testing.rst:643
msgid ""
"Whereas a mock can be used both for stubbing and mocking, a stub can only be "
"used for stubbing. Limiting a collaborator to a stub communicates its role "
"to the readers of the specification."
msgstr ""
"モックはモッキング、スタビングの両方を行うことができましたが、"
"スタブではスタビングのみが行えます。"
"これはインタラクションの機能を制限することで、読み手に対し役割をより明確にできるメリットがあります。"

# f68762c988344c7a935bea55e121fd95
#: ../../interaction_based_testing.rst:646
msgid ""
"If a stub invocation matches a *mandatory* interaction (like ``1 * foo.bar()"
"``), an ``InvalidSpecException`` is thrown."
msgstr ""
"もしスタブでインタラクションを宣言した場合は（\\ ``1 * foo.bar()``\\ のように）、"
"\\ ``InvalidSpecException``\\ がスローされます。 "

# 0b24002010864cf1abe733392c4a1364
#: ../../interaction_based_testing.rst:649
msgid ""
"Like a mock, a stub allows unexpected invocations. However, the values "
"returned by a stub in such cases are more ambitious:"
msgstr ""
"モックと同じように、スタブも予期していないメソッド呼び出しを許容しています。"
"しかし、スタブはより実際の値に近い値を返す点が異なります。"

# ce28495a0ff8466692b193420971cb2c
#: ../../interaction_based_testing.rst:651
msgid "For primitive types, the primitive type's default value is returned."
msgstr "プリミティブ型は、プリミティブ型のデフォルト値を返します。"

# b158d4b351024bac99fe364491b63229
#: ../../interaction_based_testing.rst:652
msgid ""
"For non-primitive numerical values (like ``BigDecimal``), zero is returned."
msgstr "非プリミティブ数値（\\ ``BigDecimal``\\ のような）の場合は、ゼロを返します。"

# ca3334102ab4426d8c4c49523871229b
#: ../../interaction_based_testing.rst:653
msgid ""
"For non-numerical values, an \"empty\" or \"dummy\" object is returned. This "
"could mean an empty String, an empty collection, an object constructed from "
"its default constructor, or another stub returning default values. See class "
"``org.spockframework.mock.EmptyOrDummyResponse`` for the details."
msgstr ""
"数字以外の値は\"空\"や\"ダミー\"オブジェクトを返します。"
"これは、空文字や、空のコレクション、デフォルトコンストラクトから生成したオブジェクト、"
"またはデフォルトの値を持ったスタブオブジェクトを返すということ意味します。"
"詳細は\\ ``org.spockframework.mock.EmptyOrDummyResponse``\\ クラスを参照してください。"

# aa04341a96e74bfdb4bc176ffbd4fa78
#: ../../interaction_based_testing.rst:657
msgid ""
"A stub often has a fixed set of interactions, which makes :ref:`declaring "
"interactions at mock creation time "
"<DeclaringInteractionsAtMockCreationTime>` particularly attractive::"
msgstr ""
"スタブは\\ :ref:`モック作成時のインタラクション宣言<DeclaringInteractionsAtMockCreationTime>`\\ "
"と同じように、インタラクションの固定セットを宣言することができます。"

# 0ef90c7c6fd64d84905d7e68d3ad1720
#: ../../interaction_based_testing.rst:668
msgid "Spies"
msgstr "スパイ"

# 6ccb94e03f4b4550b05efcb8aa9bcbe2
# 95016dc31a4848a68d94ba5e8056d0d2
# de02049199f14328874862cbef76d444
# 90294fa994094572a18bc6864fdf0993
# 5d1f5824887c4a0c80895f51f68f30bc
#: ../../interaction_based_testing.rst:670
#: ../../interaction_based_testing.rst:710
#: ../../interaction_based_testing.rst:758
#: ../../interaction_based_testing.rst:800
#: ../../interaction_based_testing.rst:821
msgid ""
"(Think twice before using this feature. It might be better to change the "
"design of the code under specification.)"
msgstr ""
"（この機能を使用する前に一度考えなおしてください。もしかすると"
"仕様対象のコード設計自体を見なおしたほうが良いかもしれません。）"

# e8682054d8954eca999a85eeee873280
#: ../../interaction_based_testing.rst:672
msgid "A *spy* is created with the ``MockingApi.Spy`` factory method::"
msgstr "*スパイ*\\ は\\ ``MockingApi.Spy``\\ のファクトリメソッドで作成します。"

# abe11175a6894484884a84568566c685
#: ../../interaction_based_testing.rst:676
msgid ""
"A spy is always based on a real object. Hence you must provide a class type "
"rather than an interface type, along with any constructor arguments for the "
"type. If no constructor arguments are provided, the type's default "
"constructor will be used."
msgstr ""
"スパイは常に本物のオブジェクトである必要があります。そのため、インタフェースではなく"
"クラスの型をコンストラクタの引数に指定してください。"
"もしコンストラクタの引数を指定しなかった場合は、デフォルトコンストラクタが"
"使用されます。"

# 4f11675e3f164847800f792129a5640b
#: ../../interaction_based_testing.rst:680
msgid ""
"Method calls on a spy are automatically delegated to the real object. "
"Likewise, values returned from the real object's methods are passed back to "
"the caller via the spy."
msgstr ""
"スパイのメソッド呼び出しは、自動的に本物のオブジェクトに委譲されます。"
"同様にメソッドの戻り値は、本物のオブジェクトからスパイを経由して呼び出し元に返ります。"

# ecaa3c9065a34ca890230e8443f068e7
#: ../../interaction_based_testing.rst:683
msgid ""
"After creating a spy, you can listen in on the conversation between the "
"caller and the real object underlying the spy::"
msgstr ""
"スパイを作成すると、スパイを通して行われた呼び出し元と実際のオブジェクトとの"
"やり取りを監視することができます。"

# 593688a9a96c48b79f2c4815cc605e76
#: ../../interaction_based_testing.rst:687
msgid ""
"Apart from making sure that ``receive`` gets called exactly once, the "
"conversation between the publisher and the ``SubscriberImpl`` instance "
"underlying the spy remains unaltered."
msgstr ""
"このようにpublisherと\\ ``SubscriberImpl``\\ を変更することなく、スパイを使用して"
"\\ ``receive``\\ が1回呼ばれたことを確認できます。"

# bcb6dca5cdaa413697f84e42bb3a109e
#: ../../interaction_based_testing.rst:690
msgid ""
"When stubbing a method on a spy, the real method no longer gets called::"
msgstr ""
"またスパイでメソッドのスタビングを行うと、本物のメソッドが呼ばれなくなります。"

# bbe7c076e6f34ec5af6168922b85a117
#: ../../interaction_based_testing.rst:694
msgid ""
"Instead of calling ``SubscriberImpl.receive``, the ``receive`` method will "
"now simply return ``\"ok\"``."
msgstr ""
"これは本物の\\ ``SubscriberImpl.receive``\\ が呼ばれる代わりに、\\ ``receive``\\ メソッドが"
"単に\\ ``\"ok\"``\\ を返すようになります。"

# 5e52ed2c706f43f2b8f6eac78e0019cc
#: ../../interaction_based_testing.rst:696
msgid ""
"Sometimes, it is desirable to both execute some code *and* delegate to the "
"real method::"
msgstr ""
"さらに、場合によっては、任意のコード実行と、本物のメソッドへの委譲の両方を"
"組み合わせたい場合もでしょう。"

# b9a97da4fd6843e0a2e730f82c8f6fd0
#: ../../interaction_based_testing.rst:700
msgid ""
"Here we use ``callRealMethod()`` to delegate the method invocation to the "
"real object. Note that we don't have to pass the ``message`` argument along; "
"this is taken care of automatically. `callRealMethod()`` returns the real "
"invocation's result, but in this example we opted to return our own result "
"instead. If we had wanted to pass a different message to the real method, we "
"could have used ``callRealMethodWithArgs(\"changed message\")``."
msgstr ""
"このように本物のメソッドに処理を委譲する場合は\\ ``callRealMethod()``\\ メソッドを使用します。"
"ここで、呼び出す際に\\ ``message`` の引数を設定していないことに注意してください。"
"このメソッドの引数は、Spockが自動的に設定します。この例では\\ ``callRealMethod()`` の呼び出しに"
"本当の処理結果が返りますが、この値を使用せず値を差し替えています。"
"また、呼び出しと異なる引数を、本物のメソッドに設定したい場合は"
"\\ ``callRealMethodWithArgs(\"changed message\")``\\ を使用できます。"

# 47985cbb55ed41608144f05484a699cc
#: ../../interaction_based_testing.rst:708
msgid "Partial Mocks"
msgstr "パーシャルモック"

# d62ac3f41305450e85852772a0826abd
#: ../../interaction_based_testing.rst:712
msgid "Spies can also be used as partial mocks::"
msgstr "スパイはパーシャルモックとしても使用できます。"

# c42fd6038d84449084bff592ebc17147
#: ../../interaction_based_testing.rst:730
msgid "Groovy Mocks (New in 0.7)"
msgstr "Groovyモック（New in 0.7）"

# cda61eb56c204c3e8c48fd46ebc1d644
#: ../../interaction_based_testing.rst:732
msgid ""
"So far, all the mocking features we have seen work the same no matter if the "
"calling code is written in Java or Groovy. By leveraging Groovy's dynamic "
"capabilities, Groovy mocks offer some additional features specifically for "
"testing Groovy code. They are created with the ``MockingApi.GroovyMock()``, "
"``MockingApi.GroovyStub()``, and ``MockingApi.GroovySpy()`` factory methods."
msgstr ""
"これまで説明してきたモックの機能は、呼び出し元のコードがJava、またはGroovyの"
"どちらでも問題なく動作します。Groovyモックは、"
"Groovyの動的な性質を活用したコードをテストするための、"
"Groovy固有のテスト機能をサポートしています。"
"これらは\\ ``MockingApi.GroovyMock()``\\ 、\\ ``MockingApi.GroovyStub()``\\ 、"
"\\ ``MockingApi.GroovySpy()``\\ のファクトリメソッドを使用して作成できます。"

# 8e12ecc99be642fbb7b6802a18cc1551
#: ../../interaction_based_testing.rst:738
msgid ""
"Groovy mocks should be used when the code under specification is written in "
"Groovy *and* some of the unique Groovy mock features are needed. When called "
"from Java code, Groovy mocks will behave like regular mocks. Note that it "
"isn't necessary to use a Groovy mock merely because the code under "
"specification and/or mocked type is written in Groovy. Unless you have a "
"concrete reason to use a Groovy mock, prefer a regular mock."
msgstr ""
"（質問: どのような場合に通常モックではなくGroovyモックを使用すべきか？）"
"仕様対象がGroovyを使用して書かれており、かつGroovy固有のモック機能が必要な場合に使用してください。"
"もしJavaのコードからGroovyモックが呼び出された場合は、Groovyモックは通常のモックと"
"同じように振舞います。ただしこのような場合は、そもそもGroovyモックを使用する必要が"
"ありません。Groovyモックは、Groovyで書かれたコードに対して、Groovy固有のテスト機能を追加しており、Javaから利用する際はこの機能が意味を持たないためです。"
"もし、Groovyモックを使用する特別な理由がない限り、通常のモック機能を使用してください。"

# d18076b55d31404bb35db43d0806a1ed
#: ../../interaction_based_testing.rst:744
msgid "Mocking Dynamic Methods"
msgstr "動的メソッドのモッキング"

# 1fc8b29bc2f948f7ad01ead99577754d
#: ../../interaction_based_testing.rst:746
msgid ""
"All Groovy mocks implement the ``GroovyObject`` interface. They support the "
"mocking and stubbing of dynamic methods as if they were physically declared "
"methods::"
msgstr ""
"すべてのGroovyモックは\\ ``GroovyObject``\\ のインタフェースを実装しています。"
"これらは通常のメソッドと同じように、動的メソッドへのモッキングとスタビングをサポートしています。"

# a4e7a9a6e21041e88190eedfd6dea20b
#: ../../interaction_based_testing.rst:756
msgid "Mocking All Instances of a Type"
msgstr "任意の型すべてのインスタンスをモッキング"

# b39cb451adf843acb497dd91295819e0
#: ../../interaction_based_testing.rst:760
msgid ""
"Usually, Groovy mocks need to be injected into the code under specification "
"just like regular mocks. However, when a Groovy mock is created as *global*, "
"it automagically replaces all real instances of the mocked type for the "
"duration of the feature method [#automagic]_::"
msgstr ""
"通常のモックと同様に、Groovyモックも仕様対象に対して"
"モックの設定を行う必要があります。"
"しかしGroovyモックを\\ *グローバル*\\ なモックとして作成した場合は、"
"フィーチャメソッドの実行の間、モックした型の全てのインスタンスを、自動的に"
"差し替えることができます。\\ [#automagic]_"

# 360bc3e29b4d4ba0a2b0e84be22ea490
#: ../../interaction_based_testing.rst:775
msgid ""
"Here, we set up the publisher with two instances of a real subscriber "
"implementation. Then we create a global mock of the *same* type. This "
"reroutes all method calls on the real subscribers to the mock object. The "
"mock object's instance isn't ever passed to the publisher; it is only used "
"to describe the interaction."
msgstr ""
"はじめに2つの本物のsubscriber実装インスタンスを持つpublisherを準備します。"
"次に、この本物のsubscriber実装の型を指定して、グローバルモックを作成します。"
"このようにすることで本物のsubscriberに対する全てのメソッド呼び出しが、"
"モックオブジェクトへ送られるようになります。また、ここでモックオブジェクトのインスタンスを"
"publisherに設定していません。このモックオブジェクトは、インタラクションを宣言するためだけに使用します。"

# aea9e744fecf4810ba59e56bcb4d5f23
#: ../../interaction_based_testing.rst:780
msgid ""
"A global mock can only be created for a class type. It effectively replaces "
"all instances of that type for the duration of the feature method."
msgstr ""
"グローバルモックはクラスの型にのみ使用できます。これはフィーチャメソッドが実行中の間、"
"その型の全てのインスタンスが差し替わります。"

# 8138a59cf10f44d3870400192d68abac
#: ../../interaction_based_testing.rst:783
msgid ""
"Since global mocks have a somewhat, well, global effect, it's often "
"convenient to use them together with ``GroovySpy``. This leads to the real "
"code getting executed *unless* an interaction matches, allowing you to "
"selectively listen in on objects and change their behavior just where needed."
msgstr ""
"グローバルモックは全てのインスタンスに影響を与えますが、グローバルに使用する場合は\\ ``GroovySpy``\\ "
"も非常に便利です。これは、必要な部分の動作だけ変更を行い、"
"インタラクションが\\ *一致しない*\\ 場合は実際のメソッドを実行することが可能です。"
"また、呼び出しの確認にも使用できます。"

# 83b0129da7344c0fb5a41786a160e744
#: ../../interaction_based_testing.rst:790
msgid ""
"Global Groovy mocks get their super powers from Groovy meta-programming. To "
"be more precise, every globally mocked type is assigned a custom meta class "
"for the duration of the feature method. Since a global Groovy mock is still "
"based on a CGLIB proxy, it will retain its general mocking capabilities (but "
"not its super powers) when called from Java code."
msgstr ""
"（質問: どのようにグローバルモックを実装しているか？）"
"グローバルなGroovyモックは、Groovyのメタプログラミングの超パワーを活用しています。"
"具体的には、フィーチャメソッドが実行中の間、すべてのグローバルモックの型に対し、"
"カスタムのメタクラスを設定しています。また、グローバルなGroovyモックはCGLIBのプロキシを"
"ベースに作成しているため、Javaから呼ばれた場合も、通常のモックのように"
"振る舞うことができます（ただし超パワーは発揮されません）。"

# db7c1be6744f4a09b3668274410f79ab
#: ../../interaction_based_testing.rst:798
msgid "Mocking Constructors"
msgstr "コンストラクタのモッキング"

# 54b151d48ba94e53bb175fb141ce367d
#: ../../interaction_based_testing.rst:802
msgid "Global mocks support mocking of constructors::"
msgstr "グローバルモックはコンストラクタのモッキングをサポートしています。"

# 4043e3eca2184048a8819dade70f32b1
#: ../../interaction_based_testing.rst:808
msgid ""
"Since we are using a spy, the object returned from the constructor call "
"remains unchanged. To change which object gets constructed, we can stub the "
"constructor::"
msgstr ""
"ここではスパイを使用しているため、コンストラクタの振る舞いは変更されずに、モックオブジェクトが"
"作成されます。コンストラクタの振る舞い変更するには、コンストラクタをスタビングします。"

# e75044f5380e4beb854197f9d1b275cc
#: ../../interaction_based_testing.rst:813
msgid ""
"Now, whenever some code tries to construct a subscriber named Fred, we'll "
"construct a subscriber named Barney instead."
msgstr ""
"このようにすることでFredという名前のsubscriberを構築するたびに、"
"Barneyという名前のsubscriberが代わりに構築されます。"

# d7a210665d22470086bc7deb90dc854f
#: ../../interaction_based_testing.rst:819
msgid "Mocking Static Methods"
msgstr "Staticメソッドのモッキング"

# 1ea4c3fa67714fb7af1236f79362daf4
#: ../../interaction_based_testing.rst:823
msgid "Global mocks support mocking and stubbing of static methods::"
msgstr "グローバルモックはstaticメソッドの、モッキングとスタビングをサポートしています。"

# 0a35934f567444c3ae93aaa21c29a593
#: ../../interaction_based_testing.rst:829
msgid "The same works for dynamic static methods."
msgstr "これは動的なstaticメソッドに対しても使用できます。"

# 61a5409aa39d4424a8bfab7e0061aa7d
#: ../../interaction_based_testing.rst:831
msgid ""
"When a global mock is used solely for mocking constructors and static "
"methods, the mock's instance isn't really needed. In such a case one can "
"just write::"
msgstr ""
"もしグローバルモックをコンストラクタ、またはstaticメソッドのモックにのみ"
"使用している場合は、モックインスタンスは必要がありません。"
"このような場合は、以下のように書くこともできます。"

# 98b7b14b687f465f8abd3a25bfee3f40
#: ../../interaction_based_testing.rst:837
msgid "Advanced Features (New in 0.7)"
msgstr "高度な機能（New in 0.7）"

# d08a915f4ee64f95b70098f40d36453b
#: ../../interaction_based_testing.rst:839
msgid ""
"Most of the time you shouldn't need these features. But if you do, you'll be "
"glad to have them."
msgstr ""
"ほとんどの人にとってはこの機能は必要がありません。しかし、一部のユーザにとっては"
"非常に有益な機能なはずです。"

# 34f856d6241d41ee85414e5c72587e96
#: ../../interaction_based_testing.rst:844
msgid "A la Carte Mocks"
msgstr "アラカルトモック"

# 3baaa48efa144d3fa498bd76fbb0946c
#: ../../interaction_based_testing.rst:846
msgid ""
"At the end of the day, the ``Mock()``, ``Stub()``, and ``Spy()`` factory "
"methods are just precanned ways to create mock objects with a certain "
"configuration. If you want more fine-grained control over a mock's "
"configuration, have a look at the ``org.spockframework.mock."
"IMockConfiguration`` interface. All properties of this interface "
"[#mockConfiguration]_ can be passed as named arguments to the ``Mock()`` "
"method. For example::"
msgstr ""
"これが最後の話題になります。\\ ``Mock()``\\ 、\\ ``Stub()``\\ 、そして"
"\\ ``Spy()``\\ のファクトリメソッドは、任意の構成でモックオブジェクトを作成するための"
"方法が、あらかじめ用意されています。もしこの構成をより細かく制御したい場合は、まず"
"\\ ``org.spockframework.mock.IMockConfiguration``\\ インタフェースを"
"参照してください。このインタフェース\\ [#mockConfiguration]_\\ の全てのプロパティは、"
"\\ ``Mock()``\\ メソッドへ名前付き引数として設定することができます。"
"例えば以下のように使用します。"

# b93c51442d4f4da1bf072ee2ec9c04cc
#: ../../interaction_based_testing.rst:853
msgid ""
"Here, we create a mock whose default return values match those of a ``Mock()"
"``, but whose invocations aren't verified (as for a ``Stub()``). Instead of "
"passing ``ZeroOrNullResponse``, we could have supplied our own custom ``org."
"spockframework.mock.IDefaultResponse`` for responding to unexpected method "
"invocations."
msgstr ""
"ここで作成したモックは、通常の\\ ``Mock()``\\ で作成した場合と同じ"
"デフォルト値を返しますが、（\\ ``Stub()``\\ のように）呼び出しの確認を"
"行いません。また、\\ ``ZeroOrNullResponse``\\ を設定する代わりに、"
"予期しないメソッドの呼び出しに対応するといった、独自の"
"\\ ``org.spockframework.mock.IDefaultResponse``\\ 実装を設定することも"
"できます。"

# 587b55a90aa6416bab08ee81e33984a0
#: ../../interaction_based_testing.rst:860
msgid "Detecting Mock Objects"
msgstr "モックオブジェクトの検出"

# e8fce80fcc664fb0a38e576d49ab1e9e
#: ../../interaction_based_testing.rst:862
msgid ""
"To find out whether a particular object is a Spock mock object, use a ``org."
"spockframework.mock.MockDetector``::"
msgstr ""
"オブジェクトがSpockのモックオブジェクトであるか調べるには、"
"\\ ``org.spockframework.mock.MockDetector``\\ を使用します。"

# f3b5019ad6f44b96832894384362e9c2
#: ../../interaction_based_testing.rst:872
msgid ""
"A detector can also be used to get more information about a mock object::"
msgstr ""
"また、detectorはモックオブジェクトの詳細情報を取得することもできます。"

# 6378a9ce239143a497f04809e9047c99
#: ../../interaction_based_testing.rst:882
msgid "Further Reading"
msgstr "参考文献"

# 961931152d0047d5ab3929cf67eeef7f
#: ../../interaction_based_testing.rst:884
msgid ""
"To learn more about interaction-based testing, we recommend the following "
"resources:"
msgstr ""
"相互作用中心のテストについて、次の情報を参照することをおすすめします。"

# d13528aa0fcf4ca2b5722677a0ca97ce
#: ../../interaction_based_testing.rst:886
msgid ""
"`Endo-Testing: Unit Testing with Mock Objects <http://connextra.com/aboutUs/"
"mockobjects.pdf>`_"
msgstr ""

# cb34514348b348b1a7d10a89b560f352
#: ../../interaction_based_testing.rst:888
msgid ""
"Paper from the XP2000 conference that introduces the concept of mock objects."
msgstr ""
"モックオブジェクトの概念を説明した、XP2000カンファレンスの資料"

# 85a4f7c716bb4731a5ba6eaf70389088
#: ../../interaction_based_testing.rst:890
msgid "`Mock Roles, not Objects <http://www.jmock.org/oopsla2004.pdf>`_"
msgstr ""

# 2d794e45e9cf41a4b58b2a6aaa6c022c
#: ../../interaction_based_testing.rst:892
msgid ""
"Paper from the OOPSLA2004 conference that explains how to do mocking *right*."
msgstr ""
"どのように\\ *適切*\\ にモッキングするか説明した、OOPSLA2004カンファレンスの資料"

# dcb9e04f97104827a5c9f4bae686cf4c
#: ../../interaction_based_testing.rst:894
msgid ""
"`Mocks Aren't Stubs <http://martinfowler.com/articles/mocksArentStubs.html>`_"
msgstr ""

# 01639a305c084a808e027ec9b5492794
#: ../../interaction_based_testing.rst:896
msgid "Martin Fowler's take on mocking."
msgstr "モックに関するMartin Fowlerの資料"

# c5056e4cc769445797df0b96130f3cba
#: ../../interaction_based_testing.rst:898
msgid ""
"`Growing Object-Oriented Software Guided by Tests <http://www.growing-object-"
"oriented-software.com/>`_"
msgstr ""

# 41897100ceb14a8a8fd411800b42b98b
#: ../../interaction_based_testing.rst:900
msgid ""
"TDD pioneers Steve Freeman and Nat Pryce explain in detail how test-driven "
"development and mocking work in the real world."
msgstr ""
"TDDのパイオニアであるSteve FreemanとNat Pryceが、実際にどのように"
"モックを活用しながら、テスト駆動開発を行うのか詳細に説明している"

# 654318048279431ea4b00acf7dde91a1
#: ../../interaction_based_testing.rst:903
msgid "Footnotes"
msgstr "注釈"

# 3aaffd7e0d31471384b55a88088bf388
#: ../../interaction_based_testing.rst:904
msgid ""
"For additional ways to create mock objects, see :ref:"
"`OtherKindsOfMockObjects` and :ref:`ALaCarteMocks`."
msgstr ""
"モックオブジェクトを作成する他の方法については、"
"\\ :ref:`OtherKindsOfMockObjects`\\ と\\ :ref:`ALaCarteMocks`\\ を参照してください。"

# ede8a948d5d5440497a08b5067781c1e
#: ../../interaction_based_testing.rst:907
msgid ""
"The ``subscriber`` variable cannot be referenced from the closure because it "
"is being declared as part of the same statement."
msgstr ""
"同じステートメントの一部として宣言しているため、クロージャから"
"\\ ``subscriber``\\ の変数を参照することができません。"

# 22c98e01531a45dc9be74c533a9682f2
#: ../../interaction_based_testing.rst:910
msgid ""
"You may know this behavior from Groovy's `MockFor <http://groovy.codehaus."
"org/gapi/groovy/mock/interceptor/MockFor.html>`_ and `StubFor <http://groovy."
"codehaus.org/gapi/groovy/mock/interceptor/StubFor.html>`_ facilities."
msgstr ""
"このような動作をするGroovyの"
"\\ `MockFor <http://groovy.codehaus."
"org/gapi/groovy/mock/interceptor/MockFor.html>`_\\ と\\ `StubFor <http://groovy."
"codehaus.org/gapi/groovy/mock/interceptor/StubFor.html>`_ をご存知かも知れません。"

# 7383d4ac1f2f449aaedff54fff731f13
#: ../../interaction_based_testing.rst:914
msgid ""
"The destructuring semantics for closure arguments come straight from Groovy."
msgstr ""
"このクロージャの引数の代入はGroovyの動作によるものです。"

# af41088738404398a57f4d80d5b9abd8
#: ../../interaction_based_testing.rst:916
msgid ""
"Because mock configurations are immutable, the interface contains just the "
"properties' getters."
msgstr ""
"モックの構成はイミュータブルであるため、インタフェースにはプロパティの"
"ゲッターのみが含まれています。"
