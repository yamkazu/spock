# Japanese translations for Spock Framework package.
# Copyright (C) 2012, Peter Niederwieser
# This file is distributed under the same license as the Spock Framework package.
# Kazuki YAMAMOTO <>, 2013.
#
msgid ""
msgstr ""
"Project-Id-Version: Spock Framework 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-02-14 00:20\n"
"PO-Revision-Date: 2013-02-14 00:27+0900\n"
"Last-Translator: Kazuki YAMAMOTO <>\n"
"Language-Team: Japanese\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

# 4a899b9c90434b99a81bca99aea10c64
#: ../../data_driven_testing.rst:4
msgid "Data Driven Testing"
msgstr "データ駆動テスト"

# 0466f63f3a1c4b7aaba4248d82d8e1e5
#: ../../data_driven_testing.rst:6
msgid ""
"Oftentimes, it is useful to exercise the same test code multiple times, with "
"varying inputs and expected results. Spock's data driven testing support "
"makes this a first class feature."
msgstr ""
"入力値と期待する結果の組み合わせを検証するため、同じテストコードを複数回実行したいことがあります。"
"Spockのデータ駆動テストは、これをサポートする最高の機能です。"

# 1177345c8f9d49cd82d5f9968aaed72b
#: ../../data_driven_testing.rst:10
msgid "Introduction"
msgstr "イントロダクション"

# a14b8eca1033470da9a7b2ff7c3cb2f1
#: ../../data_driven_testing.rst:12
msgid "Suppose we want to specify the behavior of the ``Math.max`` method::"
msgstr "\\ ``Math.max``\\ メソッドの振る舞いを定義したいとしましょう。"

# 0cdcd5b718584210936dd325d2743db1
#: ../../data_driven_testing.rst:24
msgid ""
"Although this approach is fine in simple cases like this one, it has some "
"potential drawbacks:"
msgstr ""
"この方法は、このような簡単な状況ではよい方法ですが、"
"いくつかの問題点があります。"

# 4c5d7d90ea8a438f8e5fc12212e7c9eb
#: ../../data_driven_testing.rst:26
msgid "Code and data are mixed and cannot easily be changed independently"
msgstr "コードとデータが混在していて、簡単にどちらかを変更できない"

# eb93b174e22b4a819063453736443591
#: ../../data_driven_testing.rst:27
msgid "Data cannot easily be auto-generated or fetched from external sources"
msgstr "データを簡単に自動生成したり、外部リソースを読み込んだりできない"

# 7ec40e0fd47a40298e5b3f57b713559f
#: ../../data_driven_testing.rst:28
msgid ""
"In order to exercise the same code multiple times, it either has to be "
"duplicated or extracted into a separate method"
msgstr ""
"同じコードを複数回実行する場合は、コードを複製するか別メソッドに抽出をする必要がある"

# f4e9681703f94e39a946c5faad1ce716
#: ../../data_driven_testing.rst:29
msgid ""
"In case of a failure, it may not be immediately clear which inputs caused "
"the failure"
msgstr ""
"実行が失敗した場合、失敗を引き起こした入力値がすぐに分からない"

# c687315a783943f5adf760be75b744ee
#: ../../data_driven_testing.rst:30
msgid ""
"Exercising the same code multiple times does not benefit from the same "
"isolation as executing separate methods does"
msgstr ""
"コードを複数回実行するために、実行するメソッドを分けるというやり方は、"
"賢いやり方ではない"

# f5d4f2cb169e4baa8ba9f8fe8c3aacba
#: ../../data_driven_testing.rst:32
msgid ""
"Spock's data-driven testing support tries to address these concerns. To get "
"started, let's refactor above code into a data-driven feature method. First, "
"we introduce three method parameters (called *data variables*) that replace "
"the hard-coded integer values::"
msgstr ""
"データ駆動テストのサポートは、この問題を解決します。"
"はじめに上記のコードを、データ駆動のフィーチャメソッドへリファクタリングをしましょう。"
"まず、ハードコーディングされている3つの整数値を、メソッドの引数（\\ *データ変数*\\ と呼びます）に置き換えます。"

# 11fe98622e9c4cdc98829e2a0b463051
#: ../../data_driven_testing.rst:45
msgid ""
"We have finished the test logic, but still need to supply the data values to "
"be used. This is done in a ``where:`` block, which always comes at the end "
"of the method. In the simplest (and most common) case, the ``where:`` block "
"holds a *data table*."
msgstr ""
"テストロジックの実装は完了ですが、入力値となるデータの指定が足りていません。"
"これはメソッドの最後にくる\\ ``where:``\\ ブロックで指定します。"
"もっとも簡単（そして最も一般的）な方法は、\\ ``where:``\\ ブロックで\\ *データテーブル*\\ を使用する方法です。"

# e08d5a0516d94e938ca032ae8163a131
#: ../../data_driven_testing.rst:49
msgid "Data Tables"
msgstr "データテーブル"

# 35c6dcc5074d417e92651708b5633187
#: ../../data_driven_testing.rst:51
msgid ""
"Data tables are a convenient way to exercise a feature method with a fixed "
"set of data values::"
msgstr ""
"データテーブルは、固定のデータセットと共に、フィーチャメソッドを実行する便利な方法です。"

# 7404df0fa57748e19de309872ee93bc4
#: ../../data_driven_testing.rst:66
msgid ""
"The first line of the table, called the *table header*, declares the data "
"variables. The subsequent lines, called *table rows*, hold the corresponding "
"values. For each row, the feature method will get executed once; we call "
"this an *iteration* of the method. If an iteration fails, the remaining "
"iterations will nevertheless be executed. All failures will be reported."
msgstr ""
"テーブルの1行目は\\ *テーブルヘッダ*\\ と呼ばれ、データ変数を定義します。"
"この後に続く行は\\ *データ行*\\ と呼ばれ、データ変数に対応する値を保持します。"
"データ行は、行ごとにそれぞれ個別のフィーチャメソッドとして実行されます。"
"これをメソッドの\\ *イテレーション*\\ と呼んでいます。"
"もしイテレーションの途中で実行が失敗した場合は、そこで停止せず、最後までイテレーションが実行されます。"
"最後に、失敗したすべてのイテレーションがレポートされます。"

# 3d8d7cad48bb439cbad6339423e3686f
#: ../../data_driven_testing.rst:71
msgid ""
"Data tables must have at least two columns. A single-column table can be "
"written as::"
msgstr ""
"データテーブルには最低でも2つの列が必要です。"
"もし列が1つのテーブルを定義したい場合は、以下のようにしてください。"

# 772ec0bb95594c49b7bec4d03c89c273
#: ../../data_driven_testing.rst:80
msgid "Isolated Execution of Iterations"
msgstr "イテレーション内での実行の分離"

# 700dbf6d88614baf90e1e8d6873e5690
#: ../../data_driven_testing.rst:82
msgid ""
"Iterations are isolated from each other in the same way as separate feature "
"methods. Each iteration gets its own instance of the specification class, "
"and the ``setup`` and ``cleanup`` methods will be called before and after "
"each iteration, respectively."
msgstr ""
"イテレーションはそれぞれ別々のフィーチャメソッドとして実行されます。"
"各イテレーションはスペッククラスである自身のインスタンスを取得し、"
"\\ ``setup``\\ 、\\ ``cleanup``\\ メソッドを、それぞれのイテレーションの実行前"
"後に呼び出します。"

# a5cd028f8e8a47199b5e46f3ad077a22
#: ../../data_driven_testing.rst:87
msgid "Sharing of Objects between Iterations"
msgstr "イテレーション間のオブジェクトの共有"

# dee4f3c8eaea4a86bd0b8e5e0164d0d1
#: ../../data_driven_testing.rst:89
msgid ""
"In order to share an object between iterations, it has to be kept in a "
"``@Shared`` or static field."
msgstr ""
"イテレーション間でオブジェクトを共有するには、\\ ``@Share``\\ またはstaticフィールドで値を保持します。"

# f3afa0fc4f3b4e63aaa648a7d2483bcd
#: ../../data_driven_testing.rst:91
msgid ""
"Only ``@Shared`` and static variables can be accessed from within a ``where:"
"`` block."
msgstr ""
"``where:``\\ ブロックからは\\ ``@Share``\\ とstaticフィールドの値のみアクセスが許可されています。"

# 621629f586584ed9a1656c0f2a679eec
#: ../../data_driven_testing.rst:93
msgid ""
"Note that such objects will also be shared with other methods. There is "
"currently no good way to share an object just between iterations of the same "
"method. If you consider this a problem, consider putting each method into a "
"separate spec, all of which can be kept in the same file. This achieves "
"better isolation at the cost of some boilerplate code."
msgstr ""
"このような、\\ ``@Share``\\ やstaticフィールドの値は、他のフィーチャメソッドへも共有されることに注意してください。"
"特定のフィーチャメソッド内に閉じて、イテレーション間でオブジェクトを共有する良い方法は、現在のところありません。"
"もし、この問題をどうしても解決したい場合は、同じファイル内にあるフィーチャメソッドを、それぞれ別々のスペックファイルに分割してください。"
"これは、わずかな重複コードのコストで、より良い分離を実現します。"

# d20c07837ede4db2898487960c3abd9f
#: ../../data_driven_testing.rst:98
msgid "Syntactic Variations"
msgstr "シンタックスのバリエーション"

# dac29bcbd7554078bd40fd05170e88d0
#: ../../data_driven_testing.rst:100
msgid ""
"The previous code can be tweaked in a few ways. First, since the ``where:`` "
"block already declares all data variables, the method parameters can be "
"omitted. [#methodParameters]_. Second, inputs and expected outputs can be "
"separated with a double pipe symbol (``||``) to visually set them apart. "
"With this, the code becomes::"
msgstr ""
"さきほどのコードは、さらにいくつか改善ができます。"
"まずはじめに、すべてのデータ変数はすでに\\ ``where:``\\ ブロックで定義しているため、メソッドのパラメータを省略できます\\ [#methodParameters]_\\ 。"
"次に、入力と期待する出力を、視覚的に区別するために、論理和の記号（``||``）で区切れます。"
"これを反映すると、コードは次のようになるでしょう。"

# 80c7a12c7d5e4334b49e270be37d8a64
#: ../../data_driven_testing.rst:118
msgid "Reporting of Failures"
msgstr "失敗のレポート"

# 7b2a521ee540458aa0708c7eea3c86c1
#: ../../data_driven_testing.rst:120
msgid ""
"Let's assume that our implementation of the ``max`` method has a flaw, and "
"one of the iterations fails::"
msgstr ""
"``max``\\ メソッドの実装に誤りがあり、とあるイテレーションの途中で失敗したとしましょう。"

# b2231c9543ec431a868d28d4feb25098
#: ../../data_driven_testing.rst:131
msgid ""
"The obvious question is: Which iteration failed, and what are its data "
"values? In our example, it isn't hard to figure out that it's the second "
"iteration that failed. At other times this can be more difficult or even "
"impossible [#impossible]_. In any case, it would be nice if Spock made it "
"loud and clear which iteration failed, rather than just reporting the "
"failure. This is the purpose of the ``@Unroll`` annotation."
msgstr ""
"何回目のイテレーションで失敗して、使用していたデータは何でしょうか？ "
"この例では、2回目のイテレーションで失敗したと把握することは難しくありません。"
"しかし、これを把握するのが非常に困難、または不可能である場合があります\\ [#impossible]_\\ 。"
"いずれにせよ、失敗をレポートするだけでなく、どのイテレーションで失敗したのか明瞭になると良いでしょう。"
"これが\\ ``@Unroll``\\ アノテーションの目的です。"

# 5c340695809e403db2d546395c42f549
#: ../../data_driven_testing.rst:137
msgid "Method Unrolling"
msgstr "メソッドのUnroll"

# 3681a09667d14981b9b25a754bf6e156
#: ../../data_driven_testing.rst:139
msgid ""
"A method annotated with ``@Unroll`` will have its iterations reported "
"independently::"
msgstr ""
"``@Unroll``\\ が付与されたメソッドは、イテレーションごとに独立した結果をレポートします。"

# ae7038a650af4991a0acfb47f8e915c6
#: ../../data_driven_testing.rst:146
msgid ""
"One reason why ``@Unroll`` isn't the default is that some execution "
"environments (in particular IDEs) expect to be told the number of test "
"methods in advance, and have certain problems if the actual number varies. "
"Another reason is that ``@Unroll`` can drastically change the number of "
"reported tests, which may not always be desirable."
msgstr ""
"（質問: なぜ\\ ``@Unroll``\\ がデフォルトになっていないのか？）"
"\\ ``@Unroll``\\ がデフォルトになっていない理由の1つは、いくつかの実行環境（特定のIDE）が、実行前にテストメソッドの数を把握できることを前提に動作しているためです。"
"これは、テストの動作後にテストメソッドの数が変わっていると問題を引き起こす場合があります。"
"他の理由としては、\\ ``@Unroll``\\ は劇的にテスト数を変化させるため、これは場合によっては望ましくないでしょう。"

# a7d914ebd7c5410aa0dac26768d71809
#: ../../data_driven_testing.rst:150
msgid ""
"Note that unrolling has no effect on how the method gets executed; it is "
"only an alternation in reporting. Depending on the execution environment, "
"the output will look something like::"
msgstr ""
"``@Unroll``\\ はメソッドの実行には影響を与えません。"
"影響があるのはレポート結果だけです。"
"実行環境によりますが、結果の出力は次のようになるでしょう。"

# de1761bb36db420c96163d4342301318
#: ../../data_driven_testing.rst:163
msgid ""
"This tells us that the second iteration (with index 1) failed. With a bit of "
"effort, we can do even better::"
msgstr ""
"これは2回目のイテレーション（インデックスは1）が失敗したことを表しています。"
"さらに、ちょっと手を加えることで、より見やすくできます。"

# 51247900c646465898dc3ec7dcfced2e
#: ../../data_driven_testing.rst:168
msgid ""
"This method name uses placeholders, denoted by a leading hash sign (``#``), "
"to refer to data variables ``a``, ``b``, and ``c``. In the output, the "
"placeholders will be replaced with concrete values::"
msgstr ""
"データ変数\\ ``a``\\ 、\\ ``b``\\ 、そして\\ ``c``\\ を参照するために、"
"データ変数の先頭にハッシュ（\\ ``#``\\ ）を付与することで、メソッド名でプレースホルダを使用できます。"
"プレースホルダの出力は、以下のように実際に使用した値に置き換えられます。"

# ed0e6339db344600a02eabbaf8dbc38c
#: ../../data_driven_testing.rst:181
msgid ""
"Now we can tell at a glance that the ``max`` method failed for inputs ``7`` "
"and ``0``. See `More on Unrolled Method Names`_ for further details on this "
"topic."
msgstr ""
"このようにすることで、\\ ``max``\\ メソッドが入力値\\ ``7``\\ と\\ ``0``\\ で失敗したことが"
"一目瞭然になります。このプレースホルダの詳細は\\ `More on Unrolled Method Names`_\\ "
"を参照してください。"

# 2d93d581e04d4fd78ab4419aee3436c4
#: ../../data_driven_testing.rst:184
msgid ""
"The ``@Unroll`` annotation can also be placed on a spec. This has the same "
"effect as placing it on each data-driven feature method of the spec."
msgstr ""
"また、\\ ``@Unroll``\\ アノテーションはスペッククラスにも付与できます。"
"これはデータ駆動テストを行うフィーチャメソッドそれぞれにアノテーションを付与した場合と"
"同じ効果が得られます。"

# f16420ab58004d298f5889935ce63e10
#: ../../data_driven_testing.rst:188
msgid "Data Pipes"
msgstr "データパイプ"

# 5b6e78d1e5b6499bb2e84892c419b112
#: ../../data_driven_testing.rst:190
msgid ""
"Data tables aren't the only way to supply values to data variables. In fact, "
"a data table is just syntactic sugar for one or more *data pipes*::"
msgstr ""
"データテーブルだけが、データ変数へデータを供給する唯一の方法ではありません。"
"データテーブルは、実際には1つ、または複数のデータパイプのシンタックスシュガー"
"です。"

# e0d7c74a0d954483a3fbf36d359e495a
#: ../../data_driven_testing.rst:199
msgid ""
"A data pipe, indicated by the left-shift (``<<``) operator, connects a data "
"variable to a *data provider*. The data provider holds all values for the "
"variable, one per iteration. Any object that Groovy knows how to iterate "
"over can be used as a data provider. This includes objects of type "
"``Collection``, ``String``, ``Iterable``, and objects implementing the "
"``Iterable`` contract. Data providers don't necessarily have to *be* the "
"data (as in the case of a ``Collection``); they can fetch data from external "
"sources like text files, databases and spreadsheets, or generate data "
"randomly. Data providers are queried for their next value only when needed "
"(before the next iteration)."
msgstr ""
"データパイプは左シフト（\\ ``<<``\\ ）演算子を使用し、データ変数と\\ *データプロバイダ*\\ を接続します。"
"データプロバイダはイテレーションごと1つ使用する、すべての値を保持します。"
"データプロバイダには、Groovyでイテレーションが可能なオブジェクトであれば、どんなオブジェクトでも使用できます。"
"これには\\ ``Collection``\\ 、\\ ``String``\\ や、\\ ``Iterable``\\ インタフェースを実装したオブジェクトが含まれます。"
"データプロバイダは必ずしも、それがデータ（例えば\\ ``Collection``\\ ）である必要はありません。"
"データプロバイダの値をテキストファイルや、データベース、スプレッドシート、またはランダムに生成したデータといった、外部リソースからデータを取得することもできます。"
"また、データプロバイダは値が必要になった時点（次のイテレーション前）で、はじめて次の値を取得します。"

# 4e01b92407154b5e81b10b702afba51f
#: ../../data_driven_testing.rst:207
msgid "Multi-Variable Data Pipes"
msgstr "データパイプで複数の値を扱う"

# 0236bc7b56e847f48bc9b11b4917a106
#: ../../data_driven_testing.rst:209
msgid ""
"If a data provider returns multiple values per iteration (as an object that "
"Groovy knows how to iterate over), it can be connected to multiple data "
"variables simultaneously. The syntax is somewhat similar to Groovy multi-"
"assignment but uses brackets instead of parentheses on the left-hand side::"
msgstr ""
"もしデータプロバイダ（Groovyがイテレーション方法を知っているオブジェクト）がイテレーションごとに複数の値を返す場合は、複数のデータ変数へ同時に接続できます。"
"シンタックスはGroovyのマルチ代入に似ていますが、左辺でパーレン（丸括弧）の代わりにブラケット（大括弧）を使用します。"

# 9b011c7f9e2741799bbd4048f712d715
#: ../../data_driven_testing.rst:221
msgid ""
"Data values that aren't of interest can be ignored with an underscore "
"(``_``)::"
msgstr ""
"使用しないデータはアンダースコア（\\ ``_``\\ ）で無視できます。"

# d688a238e35d42fba87528138b0649c6
#: ../../data_driven_testing.rst:228
msgid "Data Variable Assignment"
msgstr "データ変数への代入"

# d2310a97c8b64be5b08b6577cbb5f063
#: ../../data_driven_testing.rst:230
msgid "A data variable can be directly assigned a value::"
msgstr "データ変数へ直接、値を代入できます。"

# c41d51da10d24c2e8ebb907f7e102e69
#: ../../data_driven_testing.rst:238
msgid ""
"Assignments are re-evaluated for every iteration. As already shown above, "
"the right-hand side of an assignment may refer to other data variables::"
msgstr ""
"データ変数への代入はイテレーションごとに再評価されます。"
"また、上記のように代入の右辺で他のデータ変数を参照できます。"

# 5b4effa0cb50480e98ea05e2a7819629
#: ../../data_driven_testing.rst:250
msgid "Combining Data Tables, Data Pipes, and Variable Assignments"
msgstr "データテーブル、データパイプ、代入の組み合わせ"

# cc01193cad984cfe88acc3b171d34adf
#: ../../data_driven_testing.rst:252
msgid ""
"Data tables, data pipes, and variable assignments can be combined as needed::"
msgstr ""
"必要に応じて、データテーブル、データパイプ、代入を組み合わせて使用できます。"

# 86e090e6d3de4830af735a948f5334a1
#: ../../data_driven_testing.rst:266
msgid "Number of Iterations"
msgstr "イテレーションの回数"

# 973de7bfa21f48d6ab064bde4d2098fe
#: ../../data_driven_testing.rst:268
msgid ""
"The number of iterations depends on how much data is available. Successive "
"executions of the same method can yield different numbers of iterations. If "
"a data provider runs out of values sooner than its peers, an exception will "
"occur. Variable assignments don't affect the number of iterations. A ``where:"
"`` block that only contains assignments yields exactly one iteration."
msgstr ""
"イテレーションの回数は、使用可能なデータの量に依存しています。"
"メソッドの実行時に、イテレーションの回数が異なる場合があります。"
"このように、もしデータプロバイダが他のデータプロバイダよりも早く値が不足した場合は、例外が投げられます。"
"ただし、代入はイテレーションの回数に影響を与えません。"
"また、\\ ``where:``\\ ブロックが代入だけの場合は、1回だけイテレーションが実行されます。"

# 8d62ae9e016c443ea30af53b38d271af
#: ../../data_driven_testing.rst:274
msgid "Closing of Data Providers"
msgstr "データプロバイダのクローズ"

# 6766ce46b56d415fa28f3aa627de2567
#: ../../data_driven_testing.rst:276
msgid ""
"After all iterations have completed, the zero-argument ``close`` method is "
"called on all data providers that have such a method."
msgstr ""
"全てのイテレーションが完了した後に、データプロバイダが引数なしの\\ ``close``\\ "
"メソッドを持っている場合は、自動的にそのメソッドが呼び出されます。"

# bb11a07849024123b86611cb4342243c
#: ../../data_driven_testing.rst:280
msgid "More on Unrolled Method Names"
msgstr "Unroll時のメソッド名の詳細"

# db9fb1bb33a34596897b7ba95aaadf32
#: ../../data_driven_testing.rst:282
msgid ""
"An unrolled method name is similar to a Groovy ``GString``, except for the "
"following differences:"
msgstr ""
"Unroll時のメソッド名は、Groovyの\\ ``GString``\\ に似ていますが、以下の点が異なります。"

# e92c52f3afc046e086db8b7769060d26
#: ../../data_driven_testing.rst:284
msgid ""
"Expressions are denoted with ``#`` instead of ``$`` [#noDollar]_, and there "
"is no equivalent for the ``${...}`` syntax"
msgstr ""
"式は\\ ``$``\\ [#noDollar]_\\ の代わりに\\ ``#``\\ を使用し\\ ``${...}``\\ に相当する"
"シンタックスはない"

# e6022d8b761240b7b9d7a183ec412148
#: ../../data_driven_testing.rst:285
msgid "Expressions only support property access and zero-arg method calls"
msgstr "式はプロパティへのアクセスと引数なしのメソッド呼び出しのみサポート"

# 474767da3d7e4712bbb8ca5f65265be9
#: ../../data_driven_testing.rst:287
msgid ""
"Given a class ``Person`` with properties ``name`` and ``age``, and a data "
"variable ``person`` of type ``Person``, the following are valid method "
"names::"
msgstr ""
"``name``\\ と\\ ``age``\\ というプロパティを持つ\\ ``Person``\\ クラスがあり、"
"この\\ ``Person``\\ の型が\\ ``person``\\ というデータ変数として参照が可能な場合、"
"以下のように使用できます。"

# e871313701124699a9faf8d7893248f2
#: ../../data_driven_testing.rst:293
msgid ""
"Non-string values (like ``#person`` above) are converted to Strings "
"according to Groovy semantics."
msgstr ""
"文字列以外の値（例えば上記の\\ ``#person``\\ ）は、Groovyの挙動に従い"
"Stringに変換されます。"

# ff69824bd8194b58b7101bf182bc32d6
#: ../../data_driven_testing.rst:295
msgid "The following are invalid method names::"
msgstr "次のメソッド名は正しくありません。"

# ab5a7e6767bc4fd2a5bd2d24342ce151
#: ../../data_driven_testing.rst:300
msgid ""
"If necessary, additional data variables can be introduced to hold more "
"complex expression::"
msgstr ""
"必要に応じて、より複雑な式を保持するために、データ変数を活用することもできます。"

# 20280307babe4d0f97e3f3d30782c577
#: ../../data_driven_testing.rst:310
msgid "Footnotes"
msgstr "注記"

# f5b54334e6434c5da708b6548b46b498
#: ../../data_driven_testing.rst:311
msgid ""
"The idea behind allowing method parameters is to enable better IDE support. "
"However, recent versions of IntelliJ IDEA recognize data variables "
"automatically, and even infer their types from the values contained in the "
"data table."
msgstr ""
"メソッドの引数として宣言する理由として、よりIDEのサポートが得られやすことが上げられます。"
"しかし、最近のIntellij IDEAではデータ変数を自動的に認識し、さらにデータテーブルに含まれている値からその型を推論します。"

# adc914573b43417c8d1764943845a1cc
#: ../../data_driven_testing.rst:315
msgid ""
"For example, a feature method could use data variables in its ``setup:`` "
"block, but not in any conditions."
msgstr ""
"例えば、フィーチャメソッドはデータ変数を\\ ``setup:``\\ ブロックの中で使用できるなど、さまざまな条件で使用されます。"

# f28aa80e0a014cc3a16217f7754c8a77
#: ../../data_driven_testing.rst:317
msgid "Groovy syntax does not allow dollar signs in method names."
msgstr "Groovyのシンタックスはメソッド名にドル記号を使用できません。"
